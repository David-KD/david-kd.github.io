<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Terrain Explorer with Enemy and Health</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; }
        #healthBar { 
            position: absolute; 
            top: 40px; 
            left: 10px; 
            width: 200px; 
            height: 20px; 
            background: #ff0000; 
            border: 2px solid white;
            display: none;
        }
        #health { 
            width: 100%; 
            height: 100%; 
            background: #00ff00; 
            transition: width 0.3s ease-in-out;
        }
        #staminaBar { 
            position: absolute; 
            top: 70px; 
            left: 10px; 
            width: 200px; 
            height: 10px; 
            background: #333333; 
            border: 1px solid white;
            display: none;
        }
        #stamina { 
            width: 100%; 
            height: 100%; 
            background: #ffcc00; 
            transition: width 0.2s ease-in-out;
        }
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background 0.3s ease-out;
        }
        #stealthIndicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #healingIndicator {
            position: absolute;
            bottom: 40px;
            right: 10px;
            padding: 5px 10px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #flashlightIndicator {
            position: absolute;
            bottom: 70px;
            right: 10px;
            padding: 5px 10px;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #collectionCounter {
            position: absolute;
            top: 100px;
            left: 10px;
            padding: 5px 10px;
            color: #77ccff;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #loseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #loseScreen button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
        }
        #winScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 100, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #winScreen button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
        }
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.95)), url('https://images.unsplash.com/photo-1540427969750-1424f2fa0af8?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80');
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            color: #b3000c;
            animation: flicker 5s infinite alternate;
            overflow: hidden;
        }
        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px #b3000c, 0 0 82px #b3000c, 0 0 92px #b3000c, 0 0 102px #b3000c, 0 0 151px #b3000c;
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }
        @keyframes floating {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes fogAnimation {
            0% { opacity: 0.3; transform: translateX(-100%); }
            100% { opacity: 0.5; transform: translateX(100%); }
        }
        @keyframes drip {
            0% { transform: scaleY(0); opacity: 0; }
            5% { opacity: 0.7; }
            15% { transform: scaleY(1); }
            85% { opacity: 0.7; }
            100% { opacity: 0; }
        }
        .fog {
            position: absolute;
            width: 200%;
            height: 100%;
            background: url('https://i.imgur.com/wfDGOCh.png') repeat-x;
            background-size: contain;
            top: 0;
            left: 0;
            opacity: 0.4;
            animation: fogAnimation 60s linear infinite;
            pointer-events: none;
            filter: hue-rotate(280deg) brightness(0.5);
        }
        .fog:nth-child(2) {
            top: 20%;
            animation-duration: 120s;
            opacity: 0.2;
            background: url('https://i.imgur.com/JuVw61o.png') repeat-x;
            filter: hue-rotate(320deg) brightness(0.3);
        }
        .fog:nth-child(3) {
            top: 60%;
            animation-duration: 90s;
            animation-delay: -30s;
            opacity: 0.2;
            background: url('https://i.imgur.com/hIZLSRg.png') repeat-x;
            filter: brightness(0.3) contrast(1.5);
        }
        #mainMenu h1 {
            font-size: 4.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            font-weight: bold;
            letter-spacing: 5px;
            animation: pulse 3s infinite alternate;
            font-family: 'Courier New', monospace;
        }
        #mainMenu p {
            max-width: 700px;
            text-align: center;
            margin-bottom: 40px;
            font-size: 1.4em;
            line-height: 1.6;
            color: #bbbbbb;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
        }
        .menu-btn {
            background: #380000;
            border: 2px solid #880000;
            color: #ffffff;
            padding: 15px 40px;
            margin: 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            box-shadow: 0 0 10px #ff0000;
        }
        .menu-btn:hover {
            background: #550000;
            border-color: #ff0000;
            color: #ffffff;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            text-shadow: 0 0 5px #ffffff;
            transform: scale(1.05);
        }
        .menu-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.4), transparent);
            transition: 0.5s;
        }
        .menu-btn:hover:before {
            left: 100%;
        }
        #controls {
            margin-top: 40px;
            padding: 15px;
            background: rgba(40, 0, 0, 0.6);
            border: 1px solid #550000;
            border-radius: 0;
            text-align: center;
            color: #aaaaaa;
            box-shadow: 0 0 15px rgba(180, 0, 0, 0.5);
            max-width: 800px;
        }
        #controls p {
            margin: 8px 0;
            color: #dddddd;
            text-shadow: 1px 1px 2px black;
            font-size: 1.1em;
        }
        #controls p strong {
            color: #ffffff;
            text-shadow: 0 0 5px #ff0000;
        }
        .floating-ghost {
            position: absolute;
            font-size: 100px;
            color: rgba(255, 255, 255, 0.2);
            animation: floating 8s ease infinite;
            pointer-events: none;
            z-index: -1;
        }
        .ghost1 {
            top: 10%;
            right: 10%;
            animation-duration: 10s;
            transform: rotate(10deg);
        }
        .ghost2 {
            bottom: 10%;
            left: 15%;
            animation-duration: 13s;
            animation-delay: -2s;
            transform: rotate(-5deg) scale(0.7);
        }
        .ghost3 {
            top: 40%;
            left: 10%;
            animation-duration: 15s;
            animation-delay: -5s;
            transform: scale(0.5);
        }
        .blood-drip {
            position: absolute;
            width: 2px;
            background: #b3000c;
            top: 0;
            opacity: 0.7;
            transform-origin: top center;
            animation: drip 10s ease-in infinite;
        }
        /* Add CSS for music button */
        .music-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(100, 0, 0, 0.7);
            color: #fff;
            border: 1px solid #880000;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 10px #ff0000;
            transition: all 0.3s;
        }
        .music-btn:hover {
            background: rgba(150, 0, 0, 0.9);
            box-shadow: 0 0 15px #ff0000;
        }
    </style>
</head>
<body>
    <div id="info">WASD: Move | Shift: Run | Space: Jump | Ctrl: Toggle Crouch | F: Flashlight | Avoid the red enemy!</div>
    <div id="healthBar"><div id="health"></div></div>
    <div id="staminaBar"><div id="stamina"></div></div>
    <div id="stealthIndicator">HIDDEN</div>
    <div id="healingIndicator">HEALING</div>
    <div id="flashlightIndicator">FLASHLIGHT ON</div>
    <div id="collectionCounter">CRYSTALS: 0/10</div>
    <div id="damageOverlay"></div>
    <div id="loseScreen">
        <h1>Game Over!</h1>
        <p>You were caught by the enemy</p>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="showMainMenu()">Main Menu</button>
    </div>
    <div id="winScreen">
        <h1>You Win!</h1>
        <p>You collected all the crystals</p>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="showMainMenu()">Main Menu</button>
    </div>
    <div id="mainMenu">
        <div class="fog"></div>
        <div class="fog"></div>
        <div class="fog"></div>
        
        <div class="floating-ghost ghost1">👻</div>
        <div class="floating-ghost ghost2">👻</div>
        <div class="floating-ghost ghost3">👻</div>
        
        <!-- Create random blood drips -->
        <script>
            // This script will run when the page loads
            window.addEventListener('DOMContentLoaded', function() {
                for (let i = 0; i < 15; i++) {
                    createBloodDrip();
                }
            });
            
            function createBloodDrip() {
                const drip = document.createElement('div');
                drip.className = 'blood-drip';
                
                // Random position
                const left = Math.random() * 100;
                const height = 10 + Math.random() * 300;
                const delay = Math.random() * 5;
                
                drip.style.left = `${left}%`;
                drip.style.height = `${height}px`;
                drip.style.animationDelay = `${delay}s`;
                
                document.getElementById('mainMenu').appendChild(drip);
            }
        </script>
        
        <h1>HAUNTED TERRAIN</h1>
        <p>
            Venture into a nightmare realm where ghostly entities stalk your every move. 
            Collect the glowing crystals to escape this cursed place, but beware... 
            your light reveals both treasure and terror.
        </p>
        <button class="menu-btn" onclick="startGame()">ENTER DARKNESS</button>
        <div id="controls">
            <p><strong>SURVIVAL GUIDE:</strong></p>
            <p>WASD: Move | <strong>Shift:</strong> Run | <strong>Space:</strong> Jump | <strong>Ctrl:</strong> Crouch</p>
            <p><strong>F:</strong> Flashlight - reveals collectibles but attracts the ghost</p>
            <p>Crouch and remain still to heal when wounded</p>
            <p>Collect all crystals to escape the nightmare</p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    
    <script>
        let scene, camera, renderer, controls, terrain, enemy, lightSensitiveEnemy;
        let collectibles = [];
        let collectedCount = 0;
        let totalCollectibles = 10;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isRunning = false, isCrouching = false;
        let velocity = new THREE.Vector3();
        let enemyVelocity = new THREE.Vector3();
        let lightEnemyVelocity = new THREE.Vector3();
        let prevTime = performance.now();
        let playerHealth = 100;
        let playerStamina = 100;
        let lastDamageTime = 0;
        let enemyAttackCooldown = false;
        let lightEnemyAttackCooldown = false;
        let speedBoostActive = false;
        let speedBoostEndTime = 0;
        let crouchStartTime = 0;
        let isHealing = false;
        let lastHealTime = 0;
        let isStaminaDepleted = false;
        let flashlight, flashlightHelper;
        let isFlashlightOn = false;
        let gameOver = false;
        let gameWon = false;
        let gameStarted = false;
        let treeModel = null; // Store loaded tree model
        let treeTexture = null; // Store loaded tree texture
        let treeGroup = null; // Store the group of all trees for billboard updates
        const simplex = new SimplexNoise();
        const normalHeight = 2; // Normal player height above terrain
        const crouchHeight = 1; // Crouched player height above terrain
        const requiredCrouchTimeForHealing = 3000; // Time in ms player needs to crouch before healing starts
        const healingInterval = 500; // Time in ms between heal ticks
        const healAmount = 2; // Health points regained per tick
        const staminaRegenRate = 15; // Stamina points regained per second
        const runningStaminaDrain = 25; // Stamina points drained per second while running
        const jumpStaminaCost = 20; // Stamina cost for jumping

        function init() {
            // Initialize audio for main menu
            setupMainMenuAudio();
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const terrainSize = 1000;
            const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 128, 128);
            generateTerrainHeight(terrainGeometry);
            const terrainMaterial = new THREE.MeshLambertMaterial({ color: 0x556633 });
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);

            // Create standard enemy (red) - create immediately, don't wait for tree loading
            const enemyGeometry = new THREE.BoxGeometry(4, 4, 4);
            const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(200, 2, 200);
            // Add patrol data to enemy
            enemy.userData = {
                patrolRadius: 100, // Patrol within 100 units of player
                patrolTarget: new THREE.Vector3(),
                patrolTimer: 0,
                patrolDelay: 10000 // Change patrol point every 10 seconds
            };
            scene.add(enemy);
            
            // Create ghost enemy (transparent and floaty) - create immediately
            createGhostEnemy();

            // Add flashlight - create immediately
            setupFlashlight();
            
            // Add collectible crystals - create immediately
            createCollectibles(totalCollectibles);

            // Try to load tree model and texture, but don't block game initialization
            try {
                loadTreeAssets(function() {
                    // Add trees to the terrain after assets are loaded
                    addTrees(350);
                });
            } catch (error) {
                console.error("Error loading tree assets:", error);
                // Add fallback trees anyway
                addFallbackTrees(350);
            }

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Reduced intensity
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3); // Reduced intensity
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            scene.background = new THREE.Color(0x203040); // Darker sky color for better flashlight effect

            document.addEventListener('click', () => {
                if (!gameStarted) return;
                controls.lock();
            });
            
            controls.addEventListener('lock', () => {
                if (gameStarted) {
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('healthBar').style.display = 'block';
                    document.getElementById('staminaBar').style.display = 'block';
                    document.getElementById('collectionCounter').style.display = 'block';
                }
            });
            
            controls.addEventListener('unlock', () => {
                if (gameStarted && !gameOver && !gameWon) {
                    // Pause menu logic could go here
                }
            });
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            controls.getObject().position.y = 10;
            playerHealth = 100;
            playerStamina = 100;
            updateHealthBar();
            updateStaminaBar();
            updateCollectibleCounter();
            animate();
        }

        function startGame() {
            // Pause menu music when game starts
            if (window.menuAudio) {
                window.menuAudio.pause();
            }
            
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('healthBar').style.display = 'block';
            document.getElementById('staminaBar').style.display = 'block';
            document.getElementById('collectionCounter').style.display = 'block';
            gameStarted = true;
            gameOver = false;
            gameWon = false;
            controls.lock();
        }

        function showMainMenu() {
            // Resume menu music when returning to main menu
            if (window.menuAudio) {
                window.menuAudio.play();
            }
            
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('loseScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('info').style.display = 'none';
            document.getElementById('healthBar').style.display = 'none';
            document.getElementById('staminaBar').style.display = 'none';
            document.getElementById('stealthIndicator').style.display = 'none';
            document.getElementById('healingIndicator').style.display = 'none';
            document.getElementById('collectionCounter').style.display = 'none';
            gameStarted = false;
            controls.unlock();
        }

        function addTrees(count) {
            // If no tree model is loaded, use fallback trees
            if (!treeModel) {
                addFallbackTrees(count);
                return;
            }
            
            // Create a group to hold all trees for better organization
            const treeGroup = new THREE.Group();
            scene.add(treeGroup);
            
            for (let i = 0; i < count; i++) {
                // Random position on terrain
                const x = Math.random() * 900 - 450;
                const z = Math.random() * 900 - 450;
                
                // Get height at this position
                const y = getTerrainHeight(x, z);
                
                // Clone the tree model
                const tree = treeModel.clone();
                
                // Position tree on terrain
                tree.position.set(x, y + 6, z);
                
                // Random rotation for variety - billboards should always face camera
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                // Random scale for variety
                const scaleFactor = 1.5 + Math.random() * 1.0; // Larger scale for billboards
                tree.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // Add the tree to the tree group
                treeGroup.add(tree);
                
                // Add a second plane rotated 90 degrees for cross-billboard effect (more 3D-like)
                const crossTree = treeModel.clone();
                crossTree.position.copy(tree.position);
                crossTree.rotation.y = tree.rotation.y + Math.PI / 2;
                crossTree.scale.copy(tree.scale);
                treeGroup.add(crossTree);
            }
            
            // Set up a billboard effect to make trees always face camera
            const updateTreeBillboards = function() {
                // This function will be called each animation frame
                const v = new THREE.Vector3();
                
                // Get all tree objects from the tree group
                treeGroup.children.forEach(tree => {
                    // Billboard effect - make tree face camera
                    // Get direction from tree to camera
                    v.subVectors(camera.position, tree.position);
                    // Remove the y component to only rotate around y-axis
                    v.y = 0;
                    // Make tree face camera
                    tree.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), v.normalize());
                });
            };
            
            // Add the update function to the animation loop
            tree.userData.updateFunction = updateTreeBillboards;

            // Store treeGroup globally so we can access it in the animation loop
            treeGroup = treeGroup;
        }
        
        // Fallback method in case the FBX model fails to load
        function addFallbackTrees(count) {
            console.log("Using fallback trees");
            
            // Create tree materials
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            
            // Create different tree geometries for variety
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const leavesGeometry = new THREE.ConeGeometry(2, 6, 8);
            
            // Create a second tree type (pine tree)
            const pineLeavesMaterial = new THREE.MeshLambertMaterial({ color: 0x115522 });
            const pineGeometry = new THREE.ConeGeometry(1.5, 8, 8);
            
            for (let i = 0; i < count; i++) {
                // Random position on terrain
                const x = Math.random() * 900 - 450;
                const z = Math.random() * 900 - 450;
                
                // Get height at this position
                const y = getTerrainHeight(x, z);
                
                // Decide tree type with 65% being standard trees and 35% being pine trees
                if (Math.random() < 0.65) {
                    // Create standard tree (trunk + cone leaves)
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, y + 2.5, z);
                    scene.add(trunk);
                    
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(x, y + 7, z);
                    scene.add(leaves);
                    
                    // Add slight random rotation for variety
                    const rotation = Math.random() * 0.2 - 0.1;
                    trunk.rotation.x = rotation;
                    trunk.rotation.z = rotation;
                    leaves.rotation.x = rotation;
                    leaves.rotation.z = rotation;
                } else {
                    // Create pine tree (just a tall cone)
                    const pine = new THREE.Mesh(pineGeometry, pineLeavesMaterial);
                    pine.position.set(x, y + 4, z);
                    scene.add(pine);
                    
                    // Add slight random rotation
                    const rotation = Math.random() * 0.1 - 0.05;
                    pine.rotation.x = rotation;
                    pine.rotation.z = rotation;
                    
                    // Random scale for variety
                    const scale = 0.7 + Math.random() * 0.6;
                    pine.scale.set(scale, scale + 0.3, scale);
                }
            }
        }

        function generateTerrainHeight(geometry) {
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];
                // Significantly reduced terrain height variation (from 5/1 to 1.5/0.3)
                const height = simplex.noise2D(x * 0.002, z * 0.002) * 1.5 +
                             simplex.noise2D(x * 0.01, z * 0.01) * 0.3;
                vertices[i + 2] = height;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        function getTerrainHeight(x, z) {
            // Keep this consistent with generateTerrainHeight function
            return simplex.noise2D(x * 0.002, z * 0.002) * 1.5 +
                   simplex.noise2D(x * 0.01, z * 0.01) * 0.3;
        }

        function onKeyDown(event) {
            if (gameOver || gameWon || !gameStarted) return;
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': 
                    // Only allow running if player has stamina
                    if (playerStamina > 0 && !isStaminaDepleted) {
                        isRunning = true;
                    }
                    break;
                case 'Space': 
                    // Only allow jumping if player has enough stamina
                    if (canJump && playerStamina >= jumpStaminaCost) {
                        velocity.y += 15;
                        canJump = false;
                        // Reduce stamina for jumping
                        playerStamina = Math.max(0, playerStamina - jumpStaminaCost);
                        updateStaminaBar();
                        
                        // If stamina is depleted, disable running
                        if (playerStamina === 0) {
                            isStaminaDepleted = true;
                            isRunning = false;
                        }
                    }
                    break;
                case 'KeyF': toggleFlashlight(); break;
                case 'ControlLeft': 
                    // Toggle crouching state instead of setting it to true
                    isCrouching = !isCrouching; 
                    document.getElementById('stealthIndicator').style.display = isCrouching ? 'block' : 'none';
                    
                    // Set or clear crouch start time
                    if (isCrouching) {
                        crouchStartTime = performance.now();
                    } else {
                        isHealing = false;
                        document.getElementById('healingIndicator').style.display = 'none';
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            if (gameOver || gameWon || !gameStarted) return;
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
                // Remove the ControlLeft case since we're using toggle now
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateEnemies(time, delta) {
            // Update regular enemy
            updateEnemy(time, delta);
            
            // Update light-sensitive enemy
            updateLightSensitiveEnemy(time, delta);
        }

        function updateEnemy(time, delta) {
            if (gameOver || gameWon) return;
            const playerPos = controls.getObject().position;
            const enemyPos = enemy.position;
            
            // Calculate base detection range
            let detectionRange = 150;
            
            // Reduce detection range if player is crouching
            if (isCrouching) {
                detectionRange = 30; // Much shorter detection when crouching
            }
            
            const distanceToPlayer = playerPos.distanceTo(enemyPos);
            
            // Update patrol point if needed
            if (time - enemy.userData.patrolTimer > enemy.userData.patrolDelay) {
                updatePatrolPoint(enemy, playerPos);
                enemy.userData.patrolTimer = time;
            }
            
            // Check if enemy is in attack cooldown
            if (enemyAttackCooldown) {
                // During cooldown, move away from player slightly
                const direction = new THREE.Vector3()
                    .subVectors(enemyPos, playerPos)
                    .normalize();
                
                enemyVelocity.x = direction.x * 4 * delta;
                enemyVelocity.z = direction.z * 4 * delta;
                
                // End cooldown after 4 seconds (increased from 2 seconds)
                if (time - lastDamageTime > 4000) {
                    enemyAttackCooldown = false;
                }
            } 
            // Directly chase player if very close or within detection range
            else if (distanceToPlayer < detectionRange) {
                const direction = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize();
                
                const enemySpeed = 5; // Reduced from 8 to 5
                enemyVelocity.x = direction.x * enemySpeed * delta;
                enemyVelocity.z = direction.z * enemySpeed * delta;
            } 
            // Otherwise patrol toward the patrol point
            else {
                const patrolDirection = new THREE.Vector3()
                    .subVectors(enemy.userData.patrolTarget, enemyPos)
                    .normalize();
                
                const patrolSpeed = 3; // Slower patrol speed
                enemyVelocity.x = patrolDirection.x * patrolSpeed * delta;
                enemyVelocity.z = patrolDirection.z * patrolSpeed * delta;
                
                // If enemy is close to patrol point, slow down
                if (enemyPos.distanceTo(enemy.userData.patrolTarget) < 5) {
                    enemyVelocity.x *= 0.8;
                    enemyVelocity.z *= 0.8;
                }
            }
            
            enemyVelocity.y -= 9.8 * delta;
            
            // Get current terrain height at enemy position
            const currentEnemyTerrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            
            // Calculate potential next position
            const nextEnemyPosX = enemyPos.x + enemyVelocity.x;
            const nextEnemyPosZ = enemyPos.z + enemyVelocity.z;
            
            // Check terrain height at next position
            const nextEnemyTerrainHeight = getTerrainHeight(nextEnemyPosX, nextEnemyPosZ);
            
            // Only move horizontally if terrain isn't too steep
            const enemyHeightDifference = nextEnemyTerrainHeight - currentEnemyTerrainHeight;
            const maxEnemyClimbHeight = 3;
            
            if (enemyHeightDifference <= maxEnemyClimbHeight) {
                enemyPos.x = nextEnemyPosX;
                enemyPos.z = nextEnemyPosZ;
            }
            
            // Apply vertical movement with collision detection
            enemyPos.y += enemyVelocity.y * delta;
            
            // Keep enemy above terrain with buffer
            const enemyTerrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            const enemyHeightOffset = 2; // Enemy height above terrain
            if (enemyPos.y < enemyTerrainHeight + enemyHeightOffset) {
                enemyPos.y = enemyTerrainHeight + enemyHeightOffset;
                enemyVelocity.y = 0;
            }
            
            // Keep enemy within terrain bounds
            enemyPos.x = Math.max(-490, Math.min(490, enemyPos.x));
            enemyPos.z = Math.max(-490, Math.min(490, enemyPos.z));
            
            // Only damage player if close and enemy can "see" player and not in cooldown
            const distance = playerPos.distanceTo(enemyPos);
            if (!enemyAttackCooldown && distance < 5 && (distanceToPlayer < detectionRange) && time - lastDamageTime > 1000) {
                // Reduce health by 20%
                playerHealth -= 20;
                lastDamageTime = time;
                enemyAttackCooldown = true;
                
                // Visual indicator for enemy attack cooldown
                enemy.material.color.set(0x8800ff); // Change enemy color during cooldown
                setTimeout(() => {
                    enemy.material.color.set(0xff0000); // Change back to red after cooldown
                }, 4000); // Increased from 2000 to 4000
                
                // Show damage effect on screen
                showDamageEffect();
                
                // Player knockback effect
                const knockbackDirection = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize()
                    .multiplyScalar(10); // Increased knockback strength
                    
                velocity.x += knockbackDirection.x;
                velocity.z += knockbackDirection.z;
                
                // Activate speed boost for 3 seconds
                speedBoostActive = true;
                speedBoostEndTime = time + 3000; // 3 seconds
                
                // Add visual indicator for speed boost
                document.getElementById('damageOverlay').style.boxShadow = 'inset 0 0 50px rgba(0, 100, 255, 0.5)';
                setTimeout(() => {
                    document.getElementById('damageOverlay').style.boxShadow = 'none';
                }, 3000);
                
                // Play damage sound
                playSoundEffect('damage');
                
                // Update health bar display
                updateHealthBar();
                
                // Check for game over
                if (playerHealth <= 0) {
                    showLoseScreen();
                }
            }
            
            // Check if speed boost should end
            if (speedBoostActive && time > speedBoostEndTime) {
                speedBoostActive = false;
            }
        }

        function createGhostEnemy() {
            // Create ghost body - more organic shape than a box
            const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
            
            // Create translucent, glowing material for ghost
            const ghostMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                emissive: 0x4466ff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.1
            });
            
            // Create the main ghost body
            lightSensitiveEnemy = new THREE.Mesh(ghostGeometry, ghostMaterial);
            lightSensitiveEnemy.position.set(-200, 5, -200); // Start higher above ground
            scene.add(lightSensitiveEnemy);
            
            // Add glowing eyes to ghost
            const eyeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                emissive: 0x00ffff, 
                emissiveIntensity: 1 
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.7, 0.7, 1.5);
            lightSensitiveEnemy.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.7, 0.7, 1.5);
            lightSensitiveEnemy.add(rightEye);
            
            // Add trailing particle effect (simplified with small meshes)
            const trailGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.5
            });
            
            // Create several trailing particles
            for (let i = 0; i < 6; i++) {
                const trail = new THREE.Mesh(trailGeometry, trailMaterial.clone());
                trail.material.opacity = 0.5 - (i * 0.08); // Fade out
                trail.scale.set(1 - (i * 0.1), 1 - (i * 0.1), 1 - (i * 0.1)); // Get smaller
                trail.position.set(0, -i * 0.5, -i * 0.5); // Position behind
                trail.userData = {
                    offset: i,
                    originalOpacity: 0.5 - (i * 0.08)
                };
                lightSensitiveEnemy.add(trail);
            }
            
            // Add patrol data to ghost enemy - closer patrol radius (70 instead of 150)
            lightSensitiveEnemy.userData = {
                patrolRadius: 70, // Reduced patrol radius to stay closer to player
                patrolTarget: new THREE.Vector3(),
                patrolTimer: 5000, // Offset patrol timing from other enemy
                patrolDelay: 8000, // Reduced delay - update patrol points more frequently
                floatOffset: 0,    // For floating animation
                floatSpeed: 1 + Math.random() * 0.5, // Random float speed
                aggressiveMode: false // Track if ghost is in aggressive mode
            };
        }

        function updateGhostAppearance(isInLight) {
            // Make ghost more visible and aggressive looking when in light
            lightSensitiveEnemy.userData.aggressiveMode = isInLight;
            
            if (isInLight) {
                // Brighten the ghost when exposed to light and make it red-tinted
                lightSensitiveEnemy.material.emissiveIntensity = 1.5;
                lightSensitiveEnemy.material.opacity = 0.9;
                lightSensitiveEnemy.material.emissive.set(0xff4466); // More reddish when aggressive
                
                // Make eyes glow bright red
                lightSensitiveEnemy.children[0].material.color.set(0xff0000);
                lightSensitiveEnemy.children[1].material.color.set(0xff0000);
                lightSensitiveEnemy.children[0].material.emissiveIntensity = 5; // Brighter eyes
                lightSensitiveEnemy.children[1].material.emissiveIntensity = 5;
                
                // Scale up slightly when aggressive
                lightSensitiveEnemy.scale.set(1.3, 1.3, 1.3);
                
                // Make trails more visible and reddish
                for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                    const trail = lightSensitiveEnemy.children[i];
                    trail.material.opacity = trail.userData.originalOpacity * 2;
                    trail.material.color.set(0xff6688);
                }
            } else {
                // Make ghost more translucent and subtle when not in light
                lightSensitiveEnemy.material.emissiveIntensity = 0.5;
                lightSensitiveEnemy.material.opacity = 0.7;
                lightSensitiveEnemy.material.emissive.set(0x4466ff); // Blue when calm
                
                // Dim the eyes and return to cyan
                lightSensitiveEnemy.children[0].material.color.set(0x00ffff);
                lightSensitiveEnemy.children[1].material.color.set(0x00ffff);
                lightSensitiveEnemy.children[0].material.emissiveIntensity = 1;
                lightSensitiveEnemy.children[1].material.emissiveIntensity = 1;
                
                // Normal size when calm
                lightSensitiveEnemy.scale.set(1, 1, 1);
                
                // Make trails less visible and blue again
                for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                    const trail = lightSensitiveEnemy.children[i];
                    trail.material.opacity = trail.userData.originalOpacity;
                    trail.material.color.set(0x88ccff);
                }
            }
        }

        function updateGhostTrails(position, previousPosition) {
            // Update ghost trails to follow behind with a delay
            for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                const trail = lightSensitiveEnemy.children[i];
                const trailOffset = trail.userData.offset;
                
                // Calculate direction vector from current to previous position
                const directionX = previousPosition.x - position.x;
                const directionZ = previousPosition.z - position.z;
                
                // Position trail along this vector
                const distanceFactor = 0.5 * trailOffset;
                trail.position.x = directionX * distanceFactor;
                trail.position.z = directionZ * distanceFactor;
                
                // Fade trail opacity based on movement speed
                const speed = Math.sqrt(directionX * directionX + directionZ * directionZ);
                trail.material.opacity = Math.min(
                    trail.userData.originalOpacity * (1 + speed * 2),
                    0.6
                );
            }
        }

        function updateLightSensitiveEnemy(time, delta) {
            if (gameOver || gameWon) return;
            const playerPos = controls.getObject().position;
            const enemyPos = lightSensitiveEnemy.position;
            const previousPos = enemyPos.clone(); // Store position to calculate trail effects
            
            // Calculate base detection range - default is very low
            let detectionRange = 30; // Increased base detection from 20 to 30
            let isInLight = false;
            
            // If flashlight is on, detection range increases dramatically
            if (isFlashlightOn) {
                // Calculate angle between flashlight direction and enemy
                const flashlightDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const toEnemyDirection = new THREE.Vector3().subVectors(enemyPos, playerPos).normalize();
                
                // Dot product tells us if enemy is in flashlight cone
                const dotProduct = flashlightDirection.dot(toEnemyDirection);
                
                // If enemy is in flashlight cone (front of player) and within 50 units
                const distanceToPlayer = playerPos.distanceTo(enemyPos);
                if (dotProduct > 0.7 && distanceToPlayer < 60) { // Increased detection range to 60
                    detectionRange = 200; // Greatly increased detection
                    isInLight = true;
                }
            }
            
            // Update ghost appearance based on if it's in light
            updateGhostAppearance(isInLight);
            
            // Add floating movement to ghost (independent of patrol)
            lightSensitiveEnemy.userData.floatOffset += delta * lightSensitiveEnemy.userData.floatSpeed;
            // More erratic floating when aggressive
            const floatAmplitude = isInLight ? 2.5 : 1.5;
            const floatHeight = Math.sin(lightSensitiveEnemy.userData.floatOffset) * floatAmplitude;
            
            // Reduce detection range if player is crouching
            if (isCrouching) {
                detectionRange *= 0.5; // Half the detection range when crouching
            }
            
            const distanceToPlayer = playerPos.distanceTo(enemyPos);
            
            // Update patrol point if needed
            if (time - lightSensitiveEnemy.userData.patrolTimer > lightSensitiveEnemy.userData.patrolDelay) {
                updatePatrolPoint(lightSensitiveEnemy, playerPos);
                lightSensitiveEnemy.userData.patrolTimer = time;
            }
            
            // Check if enemy is in attack cooldown
            if (lightEnemyAttackCooldown) {
                // During cooldown, move away from player slightly
                const direction = new THREE.Vector3()
                    .subVectors(enemyPos, playerPos)
                    .normalize();
                
                lightEnemyVelocity.x = direction.x * 4 * delta;
                lightEnemyVelocity.z = direction.z * 4 * delta;
                
                // End cooldown after 4 seconds
                if (time - lastDamageTime > 4000) {
                    lightEnemyAttackCooldown = false;
                    lightSensitiveEnemy.material.emissive.set(0x4466ff); // Reset emissive color
                }
            } 
            // Only chase if within detection range and not in cooldown
            else if (distanceToPlayer < detectionRange) {
                const direction = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize();
                
                // Light sensitive enemy moves faster when it detects flashlight
                let enemySpeed = isInLight ? 15 : 6; // Increased speeds (was 10/4)
                
                // Add some randomness to movement when aggressive for more erratic behavior
                if (isInLight) {
                    direction.x += (Math.random() - 0.5) * 0.3;
                    direction.z += (Math.random() - 0.5) * 0.3;
                    direction.normalize(); // Re-normalize after adding randomness
                }
                
                lightEnemyVelocity.x = direction.x * enemySpeed * delta;
                lightEnemyVelocity.z = direction.z * enemySpeed * delta;
            } 
            // Otherwise patrol toward the patrol point
            else {
                const patrolDirection = new THREE.Vector3()
                    .subVectors(lightSensitiveEnemy.userData.patrolTarget, enemyPos)
                    .normalize();
                
                // Ghost moves faster in patrol mode to keep up with player
                const patrolSpeed = 4; // Increased from 2 to 4
                lightEnemyVelocity.x = patrolDirection.x * patrolSpeed * delta;
                lightEnemyVelocity.z = patrolDirection.z * patrolSpeed * delta;
                
                // If enemy is close to patrol point, slow down
                if (enemyPos.distanceTo(lightSensitiveEnemy.userData.patrolTarget) < 5) {
                    lightEnemyVelocity.x *= 0.8;
                    lightEnemyVelocity.z *= 0.8;
                }
            }
            
            // Apply horizontal movement (no need for terrain collision since ghost floats)
            enemyPos.x += lightEnemyVelocity.x;
            enemyPos.z += lightEnemyVelocity.z;
            
            // Apply floating movement - hover above the terrain
            const terrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            enemyPos.y = terrainHeight + 5 + floatHeight; // Float 5 units above terrain + sine wave
            
            // Keep enemy within terrain bounds
            enemyPos.x = Math.max(-490, Math.min(490, enemyPos.x));
            enemyPos.z = Math.max(-490, Math.min(490, enemyPos.z));
            
            // Update ghost trails
            updateGhostTrails(enemyPos, previousPos);
            
            // Only damage player if close and enemy can "see" player and not in cooldown
            const distance = playerPos.distanceTo(enemyPos);
            if (!lightEnemyAttackCooldown && distance < 5 && (distanceToPlayer < detectionRange) && time - lastDamageTime > 1000) {
                // Reduce health by 20%, more when ghost is aggressive
                const damage = isInLight ? 30 : 20; // More damage when aggressive
                playerHealth -= damage;
                lastDamageTime = time;
                lightEnemyAttackCooldown = true;
                
                // Visual indicator for enemy attack cooldown - change emissive color
                lightSensitiveEnemy.material.emissive.set(0x00ff00);
                
                // Show damage effect on screen
                showDamageEffect();
                
                // Player knockback effect - stronger when ghost is aggressive
                const knockbackStrength = isInLight ? 15 : 10;
                const knockbackDirection = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize()
                    .multiplyScalar(knockbackStrength);
                    
                velocity.x += knockbackDirection.x;
                velocity.z += knockbackDirection.z;
                
                // Activate speed boost for 3 seconds
                speedBoostActive = true;
                speedBoostEndTime = time + 3000; // 3 seconds
                
                // Add visual indicator for speed boost
                document.getElementById('damageOverlay').style.boxShadow = 'inset 0 0 50px rgba(0, 100, 255, 0.5)';
                setTimeout(() => {
                    document.getElementById('damageOverlay').style.boxShadow = 'none';
                }, 3000);
                
                // Play damage sound
                playSoundEffect('damage');
                
                // Update health bar display
                updateHealthBar();
                
                // Check for game over
                if (playerHealth <= 0) {
                    showLoseScreen();
                }
            }
        }

        function updatePatrolPoint(enemyObject, playerPos) {
            // Generate a random point within the patrol radius of the player
            const angle = Math.random() * Math.PI * 2;
            const minDistance = 50; // Minimum distance from player
            const patrolRadius = enemyObject.userData.patrolRadius;
            
            // For ghost enemy, reduce minimum distance to make it patrol closer
            const actualMinDistance = (enemyObject === lightSensitiveEnemy) ? 30 : minDistance;
            
            const distance = actualMinDistance + Math.random() * (patrolRadius - actualMinDistance);
            
            // Calculate patrol coordinates
            const targetX = playerPos.x + Math.cos(angle) * distance;
            const targetZ = playerPos.z + Math.sin(angle) * distance;
            
            // Clamp to terrain bounds
            const clampedX = Math.max(-490, Math.min(490, targetX));
            const clampedZ = Math.max(-490, Math.min(490, targetZ));
            
            // Get terrain height at target position
            const targetY = getTerrainHeight(clampedX, clampedZ) + 2;
            
            // Set new patrol target
            enemyObject.userData.patrolTarget.set(clampedX, targetY, clampedZ);
        }

        function updateHealthBar() {
            const healthElement = document.getElementById('health');
            // Ensure health is between 0 and 100
            playerHealth = Math.max(0, Math.min(100, playerHealth));
            healthElement.style.width = `${playerHealth}%`;
            
            // Update health bar color based on health percentage
            if (playerHealth > 60) {
                healthElement.style.background = '#00ff00'; // Green
            } else if (playerHealth > 30) {
                healthElement.style.background = '#ffff00'; // Yellow
            } else {
                healthElement.style.background = '#ff0000'; // Red
            }
            
            console.log(`Player health: ${playerHealth}%`); // Debug output
        }

        function showDamageEffect() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'rgba(255, 0, 0, 0.3)';
            
            setTimeout(() => {
                overlay.style.background = 'rgba(255, 0, 0, 0)';
            }, 300);
        }
        
        function showHealingEffect() {
            // Add a green pulse to the damage overlay
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'rgba(0, 255, 0, 0.1)';
            
            setTimeout(() => {
                overlay.style.background = 'rgba(0, 255, 0, 0)';
            }, 200);
        }
        
        function playSoundEffect(type) {
            // Simple audio feedback - can be expanded with actual audio files
            if (type === 'damage') {
                // Play damage sound if/when actual audio is implemented
                console.log('Damage sound would play here');
            } else if (type === 'collect') {
                // Play crystal collection sound
                console.log('Collection sound would play here');
            }
        }

        function showLoseScreen() {
            gameOver = true;
            document.getElementById('loseScreen').style.display = 'flex';
            document.getElementById('info').style.display = 'none';
            controls.unlock();
        }

        function restartGame() {
            gameOver = false;
            gameWon = false;
            playerHealth = 100;
            playerStamina = 100;
            isStaminaDepleted = false;
            collectedCount = 0;
            controls.getObject().position.set(0, 10, 0);
            
            // Reset enemy positions and patrol timers
            enemy.position.set(200, 2, 200);
            enemy.userData.patrolTimer = 0;
            
            // Reset ghost enemy
            lightSensitiveEnemy.position.set(-200, 5, -200);
            lightSensitiveEnemy.userData.patrolTimer = 5000; // Offset timing
            lightSensitiveEnemy.userData.floatOffset = 0; // Reset float animation
            lightSensitiveEnemy.material.emissive.set(0x4466ff); // Reset emissive color
            updateGhostAppearance(false); // Reset appearance
            
            // Recreate collectibles
            collectibles.forEach(crystal => {
                if (crystal && scene.getObjectById(crystal.id)) {
                    scene.remove(crystal);
                }
            });
            createCollectibles(totalCollectibles);
            
            document.getElementById('loseScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('stealthIndicator').style.display = 'none';
            document.getElementById('healingIndicator').style.display = 'none';
            document.getElementById('flashlightIndicator').style.display = isFlashlightOn ? 'block' : 'none';
            document.getElementById('collectionCounter').style.display = 'block';
            document.getElementById('healthBar').style.display = 'block';
            document.getElementById('staminaBar').style.display = 'block';
            document.getElementById('damageOverlay').style.background = 'rgba(255, 0, 0, 0)';
            document.getElementById('damageOverlay').style.boxShadow = 'none';
            isCrouching = false;
            isHealing = false;
            speedBoostActive = false;
            updateHealthBar();
            updateStaminaBar();
            updateCollectibleCounter();
            
            if (!gameStarted) {
                startGame();
            } else {
                controls.lock();
            }
        }

        function setupFlashlight() {
            // Create a spotlight
            flashlight = new THREE.SpotLight(0xffffff, 1, 50, Math.PI / 6, 0.5, 2);
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            flashlight.visible = false; // Off by default
            
            // Add the light and its target to the scene
            scene.add(flashlight);
            scene.add(flashlight.target);
            
            // Optional: Add helper to visualize light direction (uncomment for debugging)
            // flashlightHelper = new THREE.SpotLightHelper(flashlight);
            // scene.add(flashlightHelper);
        }

        function toggleFlashlight() {
            isFlashlightOn = !isFlashlightOn;
            flashlight.visible = isFlashlightOn;
            document.getElementById('flashlightIndicator').style.display = isFlashlightOn ? 'block' : 'none';
        }

        function updateFlashlightPosition() {
            if (!flashlight) return;
            
            // Get camera position and direction
            const cameraPosition = controls.getObject().position.clone();
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Position the flashlight slightly below the camera (as if held in hand)
            flashlight.position.copy(cameraPosition);
            flashlight.position.y -= 0.5;
            
            // Set the target position in front of the camera
            const targetPosition = cameraPosition.clone().add(cameraDirection.multiplyScalar(10));
            flashlight.target.position.copy(targetPosition);
            
            // Update helper if it exists
            if (flashlightHelper) flashlightHelper.update();
        }

        function createCollectibles(count) {
            // Create a crystal geometry
            const crystalGeometry = new THREE.OctahedronGeometry(1, 0);
            
            // Create base material (dim when not illuminated)
            const crystalMaterial = new THREE.MeshStandardMaterial({
                color: 0x77ccff,
                emissive: 0x4477aa,
                emissiveIntensity: 0.2,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            // Clear existing collectibles array if restarting
            collectibles = [];
            
            // Create crystals and place them around the map
            for (let i = 0; i < count; i++) {
                // Random position, but spread out from center
                const angle = (i / count) * Math.PI * 2; // Distribute around a circle
                const radius = 100 + Math.random() * 300; // Random radius between 100-400 units
                
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                
                // Get terrain height at position
                const y = getTerrainHeight(x, z);
                
                // Create crystal
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial.clone());
                crystal.position.set(x, y + 1.5, z); // Position slightly above terrain
                crystal.rotation.set(Math.random(), Math.random(), Math.random()); // Random rotation
                crystal.scale.set(1, 1.5, 1); // Make slightly taller
                
                // Add random rotation animation
                crystal.userData = {
                    rotationSpeed: 0.005 + Math.random() * 0.01,
                    illuminated: false,
                    collected: false,
                    originalY: y + 1.5,
                    floatOffset: 0
                };
                
                scene.add(crystal);
                collectibles.push(crystal);
            }
        }

        function updateCollectibles(time) {
            if (gameOver || gameWon) return;
            
            const playerPos = controls.getObject().position;
            
            // Get flashlight direction for testing if crystals are illuminated
            const flashlightDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Update each collectible
            collectibles.forEach(crystal => {
                if (crystal.userData.collected) return;
                
                // Animated floating effect
                crystal.userData.floatOffset = Math.sin(time * 0.001) * 0.2;
                crystal.position.y = crystal.userData.originalY + crystal.userData.floatOffset;
                
                // Rotate crystal
                crystal.rotation.y += crystal.userData.rotationSpeed;
                
                // Check if crystal is in flashlight beam
                const crystalPos = crystal.position;
                const toCollectibleDirection = new THREE.Vector3().subVectors(crystalPos, playerPos).normalize();
                const dotProduct = flashlightDirection.dot(toCollectibleDirection);
                const distanceToPlayer = playerPos.distanceTo(crystalPos);
                
                const inFlashlightBeam = isFlashlightOn && dotProduct > 0.8 && distanceToPlayer < 50;
                
                // Illuminate crystal if in flashlight beam
                if (inFlashlightBeam && !crystal.userData.illuminated) {
                    crystal.material.emissiveIntensity = 1.5;
                    crystal.userData.illuminated = true;
                } else if (!inFlashlightBeam && crystal.userData.illuminated) {
                    crystal.material.emissiveIntensity = 0.2;
                    crystal.userData.illuminated = false;
                }
                
                // Check for collection (player can only collect illuminated crystals when close)
                if (crystal.userData.illuminated && distanceToPlayer < 5) {
                    collectCrystal(crystal);
                }
            });
        }

        function collectCrystal(crystal) {
            crystal.userData.collected = true;
            scene.remove(crystal);
            
            // Play collection sound
            playSoundEffect('collect');
            
            // Increment collection counter
            collectedCount++;
            updateCollectibleCounter();
            
            // Check for win condition
            if (collectedCount >= totalCollectibles) {
                showWinScreen();
            }
        }

        function updateCollectibleCounter() {
            document.getElementById('collectionCounter').innerText = `CRYSTALS: ${collectedCount}/${totalCollectibles}`;
        }

        function showWinScreen() {
            gameWon = true;
            document.getElementById('winScreen').style.display = 'flex';
            document.getElementById('info').style.display = 'none';
            controls.unlock();
        }

        function updateStaminaBar() {
            const staminaElement = document.getElementById('stamina');
            staminaElement.style.width = `${playerStamina}%`;
            
            // Change color based on stamina level
            if (playerStamina > 60) {
                staminaElement.style.background = '#ffcc00'; // Yellow-orange
            } else if (playerStamina > 30) {
                staminaElement.style.background = '#ff8800'; // Orange
            } else {
                staminaElement.style.background = '#ff3300'; // Red-orange
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (!gameOver && !gameWon && gameStarted) {
                // Update flashlight position
                updateFlashlightPosition();
                
                // Update collectibles (animation, illumination, collection)
                updateCollectibles(time);
                
                // Update tree billboards to face camera
                updateTreeBillboards();
                
                // Check for healing conditions - player must be crouched and stationary for a period
                if (isCrouching && playerHealth < 100) {
                    // Check if player is mostly stationary
                    const isStationary = Math.abs(velocity.x) < 0.1 && Math.abs(velocity.z) < 0.1;
                    
                    if (isStationary && time - crouchStartTime > requiredCrouchTimeForHealing) {
                        // Start healing
                        if (!isHealing) {
                            isHealing = true;
                            document.getElementById('healingIndicator').style.display = 'block';
                        }
                        
                        // Apply healing at intervals
                        if (time - lastHealTime > healingInterval) {
                            playerHealth = Math.min(100, playerHealth + healAmount);
                            lastHealTime = time;
                            updateHealthBar();
                            
                            // Add healing particles or effects
                            showHealingEffect();
                        }
                    } else {
                        // If moving or not crouched long enough, stop healing
                        if (isHealing) {
                            isHealing = false;
                            document.getElementById('healingIndicator').style.display = 'none';
                        }
                    }
                }
                
                // Handle stamina regeneration/depletion
                if (isRunning && !isCrouching) {
                    // Drain stamina while running
                    playerStamina = Math.max(0, playerStamina - runningStaminaDrain * delta);
                    
                    // If stamina is fully depleted, disable running until recharged to 30%
                    if (playerStamina === 0) {
                        isStaminaDepleted = true;
                        isRunning = false;
                    }
                } else {
                    // Regenerate stamina when not running
                    playerStamina = Math.min(100, playerStamina + staminaRegenRate * delta);
                    
                    // If stamina is recharged enough, allow running again
                    if (isStaminaDepleted && playerStamina > 30) {
                        isStaminaDepleted = false;
                    }
                }
                
                // Update stamina bar
                updateStaminaBar();
                
                velocity.y -= 9.8 * delta;
                
                // Adjust speed based on running/crouching state
                let speed = 150; // Normal speed
                if (isRunning && !isCrouching && !isStaminaDepleted) {
                    speed = 300; // Running speed
                } else if (isCrouching) {
                    speed = 70; // Slower when crouching
                }
                
                // Apply speed boost if active
                if (speedBoostActive) {
                    speed *= 1.5; // 50% speed boost
                }

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(controls.getObject().quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(controls.getObject().quaternion);

                const direction = new THREE.Vector3();
                if (moveForward) direction.add(forward);
                if (moveBackward) direction.sub(forward);
                if (moveRight) direction.add(right);
                if (moveLeft) direction.sub(right);

                if (direction.length() > 0) {
                    direction.normalize().multiplyScalar(speed * delta);
                    velocity.x = direction.x;
                    velocity.z = direction.z;
                } else {
                    velocity.x *= 0.9;
                    velocity.z *= 0.9;
                }

                // Current position
                const pos = controls.getObject().position;
                const currentHeight = getTerrainHeight(pos.x, pos.z);
                
                // Sample multiple points around the player for better collision detection
                const samplePoints = [
                    {x: 0, z: 1},   // front
                    {x: 0, z: -1},  // back
                    {x: 1, z: 0},   // right
                    {x: -1, z: 0},  // left
                    {x: 0.7, z: 0.7},   // front-right
                    {x: -0.7, z: 0.7},  // front-left
                    {x: 0.7, z: -0.7},  // back-right
                    {x: -0.7, z: -0.7}  // back-left
                ];
                
                // Calculate potential next position
                const nextPosX = pos.x + velocity.x * delta;
                const nextPosZ = pos.z + velocity.z * delta;
                
                // Check if any sampled point would clip into terrain
                let canMoveX = true;
                let canMoveZ = true;
                const playerRadius = 1;
                
                for (const point of samplePoints) {
                    // Check X movement
                    const sampleX = nextPosX + point.x * playerRadius;
                    const sampleCurrentZ = pos.z + point.z * playerRadius;
                    const heightX = getTerrainHeight(sampleX, sampleCurrentZ);
                    
                    // Check Z movement
                    const sampleCurrentX = pos.x + point.x * playerRadius;
                    const sampleZ = nextPosZ + point.z * playerRadius;
                    const heightZ = getTerrainHeight(sampleCurrentX, sampleZ);
                    
                    // Calculate height differences
                    const diffX = heightX - currentHeight;
                    const diffZ = heightZ - currentHeight;
                    
                    // Maximum height player can climb
                    const maxClimbableHeight = 2;
                    
                    // Update movement flags
                    if (diffX > maxClimbableHeight) canMoveX = false;
                    if (diffZ > maxClimbableHeight) canMoveZ = false;
                }
                
                // Apply movement with collision detection
                if (canMoveX) {
                    controls.getObject().position.x = nextPosX;
                }
                
                if (canMoveZ) {
                    controls.getObject().position.z = nextPosZ;
                }
                
                // Apply vertical movement
                controls.getObject().position.y += velocity.y * delta;
                
                // Get terrain height at current position for ground collision
                const terrainHeight = getTerrainHeight(
                    controls.getObject().position.x, 
                    controls.getObject().position.z
                );
                
                // Set player height based on crouching state with a buffer to prevent clipping
                const playerHeightOffset = isCrouching ? crouchHeight : normalHeight;
                
                // Apply ground collision with better buffer
                if (controls.getObject().position.y < terrainHeight + playerHeightOffset + 0.2) {
                    controls.getObject().position.y = terrainHeight + playerHeightOffset + 0.2;
                    velocity.y = 0;
                    canJump = true;
                }

                // Keep player within terrain bounds
                pos.x = Math.max(-490, Math.min(490, pos.x));
                pos.z = Math.max(-490, Math.min(490, pos.z));

                // Update both enemies
                updateEnemies(time, delta);
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // Add this function after init() but before animate()
        function setupMainMenuAudio() {
            // Create audio element
            window.menuAudio = new Audio('Whispers in the Pines.mp3');
            window.menuAudio.loop = true;
            window.menuAudio.volume = 0.5;
            
            // Create play button that will be displayed if autoplay is blocked
            const musicBtn = document.createElement('button');
            musicBtn.innerHTML = "🔊 PLAY MUSIC";
            musicBtn.className = "music-btn";
            musicBtn.id = "musicButton";
            
            // Add button to page
            document.body.appendChild(musicBtn);
            
            // Setup click handler for music button
            musicBtn.addEventListener('click', function() {
                if (window.menuAudio.paused) {
                    window.menuAudio.play();
                    this.innerHTML = "🔊 MUTE MUSIC";
                } else {
                    window.menuAudio.pause();
                    this.innerHTML = "🔊 PLAY MUSIC";
                }
            });
            
            // Try to play audio (might be blocked by browser policies)
            const playPromise = window.menuAudio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Autoplay prevented. User interaction required to play audio.");
                    // Keep button visible if autoplay is blocked
                });
            }
            
            // When the document is clicked anywhere, also try to play the audio
            document.addEventListener('click', function audioClickHandler() {
                if (window.menuAudio && window.menuAudio.paused) {
                    window.menuAudio.play();
                    // Update button text
                    const musicButton = document.getElementById('musicButton');
                    if (musicButton) {
                        musicButton.innerHTML = "🔊 MUTE MUSIC";
                    }
                }
                // Remove this listener once it's triggered successfully
                if (!window.menuAudio.paused) {
                    document.removeEventListener('click', audioClickHandler);
                }
            }, { once: false });
            
            return window.menuAudio;
        }

        // Function to load tree assets (model and texture)
        function loadTreeAssets(callback) {
            try {
                // Check if FBXLoader exists already
                if (typeof THREE.FBXLoader === 'undefined') {
                    // Load FBX model loader if not included
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FBXLoader.js';
                    document.head.appendChild(script);
                    
                    script.onload = function() {
                        loadTreeFiles(callback);
                    };
                    
                    script.onerror = function() {
                        console.error("Failed to load FBXLoader script");
                        addFallbackTrees(350);
                        if (callback) callback();
                    };
                } else {
                    // FBXLoader already exists, just load the files
                    loadTreeFiles(callback);
                }
            } catch (error) {
                console.error("Error in loadTreeAssets:", error);
                addFallbackTrees(350);
                if (callback) callback();
            }
        }
        
        function loadTreeFiles(callback) {
            try {
                // First load texture
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load('tree01.png', 
                    // Success callback
                    function(texture) {
                        treeTexture = texture;
                        
                        try {
                            // Check if FBXLoader was properly loaded
                            if (typeof THREE.FBXLoader === 'undefined') {
                                throw new Error("FBXLoader not available");
                            }
                            
                            // Then load FBX model
                            const fbxLoader = new THREE.FBXLoader();
                            fbxLoader.load('tree01.fbx', 
                                // Success callback
                                function(object) {
                                    treeModel = object;
                                    
                                    // Apply texture to the model
                                    treeModel.traverse(function(child) {
                                        if (child.isMesh) {
                                            child.material = new THREE.MeshStandardMaterial({
                                                map: treeTexture,
                                                alphaTest: 0.5, // For transparent parts of the texture
                                                side: THREE.DoubleSide
                                            });
                                        }
                                    });
                                    
                                    // Scale the model down if needed
                                    treeModel.scale.set(0.05, 0.05, 0.05);
                                    
                                    // Execute callback when everything is loaded
                                    if (callback) callback();
                                }, 
                                // Progress callback
                                function(xhr) {
                                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                                },
                                // Error callback
                                function(error) {
                                    console.error('Error loading tree model:', error);
                                    // Continue with fallback method if model fails to load
                                    addFallbackTrees(350);
                                    if (callback) callback();
                                }
                            );
                        } catch (error) {
                            console.error("Error loading FBX model:", error);
                            addFallbackTrees(350);
                            if (callback) callback();
                        }
                    }, 
                    // Progress callback for texture
                    undefined,
                    // Error callback for texture
                    function(error) {
                        console.error('Error loading tree texture:', error);
                        // Continue with fallback method if texture fails to load
                        addFallbackTrees(350);
                        if (callback) callback();
                    }
                );
            } catch (error) {
                console.error("Error in loadTreeFiles:", error);
                addFallbackTrees(350);
                if (callback) callback();
            }
        }

        function loadTreeAssets(callback) {
            // Just load the tree texture directly - no need for FBXLoader
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('tree01.png', 
                // Success callback
                function(texture) {
                    console.log("Tree texture loaded successfully");
                    
                    // Create a material using the loaded texture
                    const treeMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        alphaTest: 0.5,
                        side: THREE.DoubleSide
                    });
                    
                    // Create simple billboard trees using the texture
                    createSimpleTrees(350, treeMaterial);
                    
                    // Execute callback when trees are created
                    if (callback) callback();
                }, 
                // Error callback
                function(error) {
                    console.error('Error loading tree texture:', error);
                    // Continue with fallback method if texture fails to load
                    addFallbackTrees(350);
                    if (callback) callback();
                }
            );
        }
        
        function createSimpleTrees(count, material) {
            console.log("Creating simple billboard trees with texture");
            
            // Create a plane geometry for the tree billboard
            const treeGeometry = new THREE.PlaneGeometry(10, 15);
            
            for (let i = 0; i < count; i++) {
                // Random position on terrain
                const x = Math.random() * 900 - 450;
                const z = Math.random() * 900 - 450;
                
                // Get height at this position
                const y = getTerrainHeight(x, z);
                
                // Create a tree billboard - two crossed planes
                const treeGroup = new THREE.Group();
                
                // First plane
                const tree1 = new THREE.Mesh(treeGeometry, material);
                tree1.position.set(0, 7, 0); // Center origin, but raise up
                treeGroup.add(tree1);
                
                // Second plane (rotated 90 degrees)
                const tree2 = new THREE.Mesh(treeGeometry, material);
                tree2.position.set(0, 7, 0);
                tree2.rotation.y = Math.PI / 2;
                treeGroup.add(tree2);
                
                // Position the tree group
                treeGroup.position.set(x, y, z);
                
                // Random rotation around Y axis
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                
                // Random scale for variety
                const scale = 0.8 + Math.random() * 0.6;
                treeGroup.scale.set(scale, scale, scale);
                
                // Add to scene
                scene.add(treeGroup);
            }
        }

        function updateTreeBillboards() {
            // Skip if treeGroup doesn't exist or has no children
            if (!treeGroup || !treeGroup.children || treeGroup.children.length === 0) {
                return;
            }
            
            try {
                // This function will be called each animation frame
                const v = new THREE.Vector3();
                
                // Get all tree objects from the tree group
                treeGroup.children.forEach(tree => {
                    try {
                        // Billboard effect - make tree face camera
                        // Get direction from tree to camera
                        v.subVectors(camera.position, tree.position);
                        // Remove the y component to only rotate around y-axis
                        v.y = 0;
                        
                        // Only normalize if vector has length
                        if (v.length() > 0) {
                            v.normalize();
                            // Make tree face camera
                            tree.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), v);
                        }
                    } catch (error) {
                        // Silent catch for individual tree errors
                    }
                });
            } catch (error) {
                console.error("Error in updateTreeBillboards:", error);
            }
        }

        init();
    </script>
</body>
</html>