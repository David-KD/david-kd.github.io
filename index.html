<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Terrain Explorer with Enemy and Health</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; }
        #healthBar { 
            position: absolute; 
            top: 40px; 
            left: 10px; 
            width: 200px; 
            height: 20px; 
            background: #ff0000; 
            border: 2px solid white;
            display: none;
        }
        #health { 
            width: 100%; 
            height: 100%; 
            background: #00ff00; 
            transition: width 0.3s ease-in-out;
        }
        #staminaBar { 
            position: absolute; 
            top: 70px; 
            left: 10px; 
            width: 200px; 
            height: 10px; 
            background: #333333; 
            border: 1px solid white;
            display: none;
        }
        #stamina { 
            width: 100%; 
            height: 100%; 
            background: #ffcc00; 
            transition: width 0.2s ease-in-out;
        }
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background 0.3s ease-out;
        }
        #stealthIndicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #healingIndicator {
            position: absolute;
            bottom: 40px;
            right: 10px;
            padding: 5px 10px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #flashlightIndicator {
            position: absolute;
            bottom: 70px;
            right: 10px;
            padding: 5px 10px;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #collectionCounter {
            position: absolute;
            top: 100px;
            left: 10px;
            padding: 5px 10px;
            color: #77ccff;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            display: none;
        }
        #loseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #loseScreen button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
        }
        #winScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 100, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        #winScreen button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
        }
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.95)), url('https://images.unsplash.com/photo-1540427969750-1424f2fa0af8?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80');
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            color: #b3000c;
            animation: flicker 5s infinite alternate;
            overflow: hidden;
        }
        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px #b3000c, 0 0 82px #b3000c, 0 0 92px #b3000c, 0 0 102px #b3000c, 0 0 151px #b3000c;
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }
        @keyframes floating {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes fogAnimation {
            0% { opacity: 0.3; transform: translateX(-100%); }
            100% { opacity: 0.5; transform: translateX(100%); }
        }
        @keyframes drip {
            0% { transform: scaleY(0); opacity: 0; }
            5% { opacity: 0.7; }
            15% { transform: scaleY(1); }
            85% { opacity: 0.7; }
            100% { opacity: 0; }
        }
        .fog {
            position: absolute;
            width: 200%;
            height: 100%;
            background: url('https://i.imgur.com/wfDGOCh.png') repeat-x;
            background-size: contain;
            top: 0;
            left: 0;
            opacity: 0.4;
            animation: fogAnimation 60s linear infinite;
            pointer-events: none;
            filter: hue-rotate(280deg) brightness(0.5);
        }
        .fog:nth-child(2) {
            top: 20%;
            animation-duration: 120s;
            opacity: 0.2;
            background: url('https://i.imgur.com/JuVw61o.png') repeat-x;
            filter: hue-rotate(320deg) brightness(0.3);
        }
        .fog:nth-child(3) {
            top: 60%;
            animation-duration: 90s;
            animation-delay: -30s;
            opacity: 0.2;
            background: url('https://i.imgur.com/hIZLSRg.png') repeat-x;
            filter: brightness(0.3) contrast(1.5);
        }
        #mainMenu h1 {
            font-size: 4.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            font-weight: bold;
            letter-spacing: 5px;
            animation: pulse 3s infinite alternate;
            font-family: 'Courier New', monospace;
        }
        #mainMenu p {
            max-width: 700px;
            text-align: center;
            margin-bottom: 40px;
            font-size: 1.4em;
            line-height: 1.6;
            color: #bbbbbb;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
        }
        .menu-btn {
            background: #380000;
            border: 2px solid #880000;
            color: #ffffff;
            padding: 15px 40px;
            margin: 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            box-shadow: 0 0 10px #ff0000;
        }
        .menu-btn:hover {
            background: #550000;
            border-color: #ff0000;
            color: #ffffff;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            text-shadow: 0 0 5px #ffffff;
            transform: scale(1.05);
        }
        .menu-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.4), transparent);
            transition: 0.5s;
        }
        .menu-btn:hover:before {
            left: 100%;
        }
        #controls {
            margin-top: 40px;
            padding: 15px;
            background: rgba(40, 0, 0, 0.6);
            border: 1px solid #550000;
            border-radius: 0;
            text-align: center;
            color: #aaaaaa;
            box-shadow: 0 0 15px rgba(180, 0, 0, 0.5);
            max-width: 800px;
        }
        #controls p {
            margin: 8px 0;
            color: #dddddd;
            text-shadow: 1px 1px 2px black;
            font-size: 1.1em;
        }
        #controls p strong {
            color: #ffffff;
            text-shadow: 0 0 5px #ff0000;
        }
        .floating-ghost {
            position: absolute;
            font-size: 100px;
            color: rgba(255, 255, 255, 0.2);
            animation: floating 8s ease infinite;
            pointer-events: none;
            z-index: -1;
        }
        .ghost1 {
            top: 10%;
            right: 10%;
            animation-duration: 10s;
            transform: rotate(10deg);
        }
        .ghost2 {
            bottom: 10%;
            left: 15%;
            animation-duration: 13s;
            animation-delay: -2s;
            transform: rotate(-5deg) scale(0.7);
        }
        .ghost3 {
            top: 40%;
            left: 10%;
            animation-duration: 15s;
            animation-delay: -5s;
            transform: scale(0.5);
        }
        .blood-drip {
            position: absolute;
            width: 2px;
            background: #b3000c;
            top: 0;
            opacity: 0.7;
            transform-origin: top center;
            animation: drip 10s ease-in infinite;
        }
        /* Add CSS for music button */
        .music-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(100, 0, 0, 0.7);
            color: #fff;
            border: 1px solid #880000;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 10px #ff0000;
            transition: all 0.3s;
        }
        .music-btn:hover {
            background: rgba(150, 0, 0, 0.9);
            box-shadow: 0 0 15px #ff0000;
        }
    </style>
</head>
<body>
    <div id="info">WASD: Move | Shift: Run | Space: Jump | Ctrl: Toggle Crouch | F: Flashlight | Avoid the red enemy!</div>
    <div id="healthBar"><div id="health"></div></div>
    <div id="staminaBar"><div id="stamina"></div></div>
    <div id="stealthIndicator">HIDDEN</div>
    <div id="healingIndicator">HEALING</div>
    <div id="flashlightIndicator">FLASHLIGHT ON</div>
    <div id="collectionCounter">CRYSTALS: 0/10</div>
    <div id="damageOverlay"></div>
    <div id="loseScreen">
        <h1>Game Over!</h1>
        <p>You were caught by the enemy</p>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="showMainMenu()">Main Menu</button>
    </div>
    <div id="winScreen">
        <h1>You Win!</h1>
        <p>You collected all the crystals</p>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="showMainMenu()">Main Menu</button>
    </div>
    <div id="mainMenu">
        <div class="fog"></div>
        <div class="fog"></div>
        <div class="fog"></div>
        
        <div class="floating-ghost ghost1">👻</div>
        <div class="floating-ghost ghost2">👻</div>
        <div class="floating-ghost ghost3">👻</div>
        
        <!-- Create random blood drips -->
        <script>
            // This script will run when the page loads
            window.addEventListener('DOMContentLoaded', function() {
                for (let i = 0; i < 15; i++) {
                    createBloodDrip();
                }
            });
            
            function createBloodDrip() {
                const drip = document.createElement('div');
                drip.className = 'blood-drip';
                
                // Random position
                const left = Math.random() * 100;
                const height = 10 + Math.random() * 300;
                const delay = Math.random() * 5;
                
                drip.style.left = `${left}%`;
                drip.style.height = `${height}px`;
                drip.style.animationDelay = `${delay}s`;
                
                document.getElementById('mainMenu').appendChild(drip);
            }
        </script>
        
        <h1>HAUNTED TERRAIN</h1>
        <p>
            Venture into a nightmare realm where ghostly entities stalk your every move. 
            Collect the glowing crystals to escape this cursed place, but beware... 
            your light reveals both treasure and terror.
        </p>
        <button class="menu-btn" onclick="startGame()">ENTER DARKNESS</button>
        <div id="controls">
            <p><strong>SURVIVAL GUIDE:</strong></p>
            <p>WASD: Move | <strong>Shift:</strong> Run | <strong>Space:</strong> Jump | <strong>Ctrl:</strong> Crouch</p>
            <p><strong>F:</strong> Flashlight - reveals collectibles but attracts the ghost</p>
            <p>Crouch and remain still to heal when wounded</p>
            <p>Collect all crystals to escape the nightmare</p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    
    <script>
        let scene, camera, renderer, controls, terrain, enemy, lightSensitiveEnemy;
        let collectibles = [];
        let collectedCount = 0;
        let totalCollectibles = 10;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isRunning = false, isCrouching = false;
        let velocity = new THREE.Vector3();
        let enemyVelocity = new THREE.Vector3();
        let lightEnemyVelocity = new THREE.Vector3();
        let prevTime = performance.now();
        let playerHealth = 100;
        let playerStamina = 100;
        let lastDamageTime = 0;
        let enemyAttackCooldown = false;
        let lightEnemyAttackCooldown = false;
        let speedBoostActive = false;
        let speedBoostEndTime = 0;
        let crouchStartTime = 0;
        let isHealing = false;
        let lastHealTime = 0;
        let isStaminaDepleted = false;
        let flashlight, flashlightHelper;
        let isFlashlightOn = false;
        let gameOver = false;
        let gameWon = false;
        let gameStarted = false;
        // Audio variables
        let gameplayAudio;
        let monsterDetectSfx; // Sound for ground monster detection
        let ghostDetectSfx; // Sound for ghost detection
        
        // Audio handling function to ensure sounds play
        function playDetectionSound(soundType) {
            console.log(`Attempting to play ${soundType} detection sound...`);
            
            let audioElement;
            if (soundType === 'monster') {
                // Create a new audio element for monster sound
                audioElement = new Audio('Monster SFX.mp3');
                audioElement.volume = 1.0;
            } else if (soundType === 'ghost') {
                // Create a new audio element for ghost sound
                audioElement = new Audio('qubodup-GhostMoan03.mp3');
                audioElement.volume = 1.0;
            } else {
                console.error(`Unknown sound type: ${soundType}`);
                return;
            }
            
            // Log detailed information about the audio element
            console.log(`Audio element created for ${soundType}:`, audioElement);
            
            // Add event listeners to track loading and playing state
            audioElement.addEventListener('canplaythrough', () => {
                console.log(`${soundType} sound loaded and ready to play`);
                
                // Play the sound as soon as it's ready
                const playPromise = audioElement.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log(`${soundType} sound started playing successfully!`);
                    }).catch(error => {
                        console.error(`Error playing ${soundType} sound:`, error);
                        
                        // If autoplay is prevented, create a temporary button to allow user interaction
                        if (error.name === 'NotAllowedError') {
                            const tempButton = document.createElement('button');
                            tempButton.textContent = `Play ${soundType} Sound`;
                            tempButton.style.position = 'absolute';
                            tempButton.style.top = '50%';
                            tempButton.style.left = '50%';
                            tempButton.style.transform = 'translate(-50%, -50%)';
                            tempButton.style.zIndex = '10000';
                            tempButton.style.padding = '20px';
                            
                            tempButton.onclick = () => {
                                audioElement.play()
                                    .then(() => {
                                        console.log(`${soundType} sound started after user interaction`);
                                        document.body.removeChild(tempButton);
                                    })
                                    .catch(err => {
                                        console.error(`Still failed to play ${soundType} sound:`, err);
                                    });
                            };
                            
                            document.body.appendChild(tempButton);
                        }
                    });
                }
            });
            
            audioElement.addEventListener('error', (e) => {
                console.error(`Error loading ${soundType} sound:`, e);
                alert(`Failed to load ${soundType} sound file. Check console for details.`);
            });
            
            // Force load the audio
            audioElement.load();
        }
        const simplex = new SimplexNoise();
        const normalHeight = 2; // Normal player height above terrain
        const crouchHeight = 1; // Crouched player height above terrain
        const requiredCrouchTimeForHealing = 3000; // Time in ms player needs to crouch before healing starts
        const healingInterval = 500; // Time in ms between heal ticks
        const healAmount = 2; // Health points regained per tick
        const staminaRegenRate = 15; // Stamina points regained per second
        const runningStaminaDrain = 25; // Stamina points drained per second while running
        const jumpStaminaCost = 20; // Stamina cost for jumping

        function init() {
            // Initialize audio for main menu
            setupMainMenuAudio();
            
            // Add debug buttons for testing sounds (can be removed after debugging)
            addDebugSoundButtons();
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add a dark skybox with stars
            createSkybox();

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const terrainSize = 1000;
            const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 128, 128);
            generateTerrainHeight(terrainGeometry);
            const terrainMaterial = new THREE.MeshLambertMaterial({ color: 0x556633 });
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);

            // Create a more scary ground enemy instead of a simple red box
            createGroundMonster();
            
            // Create ghost enemy (transparent and floaty) - create immediately
            createGhostEnemy();

            // Add flashlight - create immediately
            setupFlashlight();
            
            // Add collectible crystals - create immediately
            createCollectibles(totalCollectibles);

            // Skip tree loading and directly add trees
            addTrees(350);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Reduced intensity
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3); // Reduced intensity
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Add subtle fog for a spookier atmosphere
            scene.fog = new THREE.FogExp2(0x0A1525, 0.0015); // Dark blue fog that increases exponentially with distance

            document.addEventListener('click', () => {
                if (!gameStarted) return;
                controls.lock();
            });
            
            controls.addEventListener('lock', () => {
                if (gameStarted) {
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('healthBar').style.display = 'block';
                    document.getElementById('staminaBar').style.display = 'block';
                    document.getElementById('collectionCounter').style.display = 'block';
                }
            });
            
            controls.addEventListener('unlock', () => {
                if (gameStarted && !gameOver && !gameWon) {
                    // Pause menu logic could go here
                }
            });
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            controls.getObject().position.y = 10;
            playerHealth = 100;
            playerStamina = 100;
            updateHealthBar();
            updateStaminaBar();
            updateCollectibleCounter();
            animate();
        }

        function startGame() {
            // Always pause menu music when game starts
            if (window.menuAudio) {
                window.menuAudio.pause();
            }
            
            // Start gameplay music
            if (gameplayAudio) {
                gameplayAudio.currentTime = 0; // Start from beginning
                gameplayAudio.play().catch(e => {
                    console.log("Couldn't autoplay gameplay music: ", e);
                });
                
                // Update music button text if it exists
                const musicButton = document.getElementById('musicButton');
                if (musicButton) {
                    musicButton.innerHTML = "🔊 MUSIC ON";
                }
            }
            
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('healthBar').style.display = 'block';
            document.getElementById('staminaBar').style.display = 'block';
            document.getElementById('collectionCounter').style.display = 'block';
            gameStarted = true;
            gameOver = false;
            gameWon = false;
            controls.lock();
        }

        function showMainMenu() {
            // Pause gameplay music when returning to menu
            if (gameplayAudio) {
                gameplayAudio.pause();
            }
            
            // Stop any playing sound effects
            if (monsterDetectSfx) {
                monsterDetectSfx.pause();
                monsterDetectSfx.currentTime = 0;
            }
            if (ghostDetectSfx) {
                ghostDetectSfx.pause();
                ghostDetectSfx.currentTime = 0;
            }
            
            // Resume menu music when returning to main menu
            if (window.menuAudio) {
                window.menuAudio.play().catch(e => {
                    console.log("Couldn't autoplay menu music: ", e);
                });
                
                // Update music button text
                const musicButton = document.getElementById('musicButton');
                if (musicButton) {
                    musicButton.innerHTML = "🔊 MUSIC ON";
                }
            }
            
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('loseScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('info').style.display = 'none';
            document.getElementById('healthBar').style.display = 'none';
            document.getElementById('staminaBar').style.display = 'none';
            document.getElementById('stealthIndicator').style.display = 'none';
            document.getElementById('healingIndicator').style.display = 'none';
            document.getElementById('collectionCounter').style.display = 'none';
            gameStarted = false;
            controls.unlock();
        }

        // Create and add trees to the scene
        function addTrees(count) {
            console.log("Adding trees");
            
            // Create tree materials
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            
            // Create different tree geometries for variety
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const leavesGeometry = new THREE.ConeGeometry(2, 6, 8);
            
            // Create a second tree type (pine tree)
            const pineLeavesMaterial = new THREE.MeshLambertMaterial({ color: 0x115522 });
            const pineGeometry = new THREE.ConeGeometry(1.5, 8, 8);
            
            for (let i = 0; i < count; i++) {
                // Random position on terrain
                const x = Math.random() * 900 - 450;
                const z = Math.random() * 900 - 450;
                
                // Get height at this position
                const y = getTerrainHeight(x, z);
                
                // Decide tree type with 65% being standard trees and 35% being pine trees
                if (Math.random() < 0.65) {
                    // Create standard tree (trunk + cone leaves)
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, y + 2.5, z);
                    scene.add(trunk);
                    
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(x, y + 7, z);
                    scene.add(leaves);
                    
                    // Add slight random rotation for variety
                    const rotation = Math.random() * 0.2 - 0.1;
                    trunk.rotation.x = rotation;
                    trunk.rotation.z = rotation;
                    leaves.rotation.x = rotation;
                    leaves.rotation.z = rotation;
                } else {
                    // Create pine tree (just a tall cone)
                    const pine = new THREE.Mesh(pineGeometry, pineLeavesMaterial);
                    pine.position.set(x, y + 4, z);
                    scene.add(pine);
                    
                    // Add slight random rotation
                    const rotation = Math.random() * 0.1 - 0.05;
                    pine.rotation.x = rotation;
                    pine.rotation.z = rotation;
                    
                    // Random scale for variety
                    const scale = 0.7 + Math.random() * 0.6;
                    pine.scale.set(scale, scale + 0.3, scale);
                }
            }
        }

        function generateTerrainHeight(geometry) {
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];
                // Significantly reduced terrain height variation (from 5/1 to 1.5/0.3)
                const height = simplex.noise2D(x * 0.002, z * 0.002) * 1.5 +
                             simplex.noise2D(x * 0.01, z * 0.01) * 0.3;
                vertices[i + 2] = height;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        function getTerrainHeight(x, z) {
            // Keep this consistent with generateTerrainHeight function
            return simplex.noise2D(x * 0.002, z * 0.002) * 1.5 +
                   simplex.noise2D(x * 0.01, z * 0.01) * 0.3;
        }

        function onKeyDown(event) {
            if (gameOver || gameWon || !gameStarted) return;
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': 
                    // Only allow running if player has stamina
                    if (playerStamina > 0 && !isStaminaDepleted) {
                        isRunning = true;
                    }
                    break;
                case 'Space': 
                    // Only allow jumping if player has enough stamina
                    if (canJump && playerStamina >= jumpStaminaCost) {
                        velocity.y += 15;
                        canJump = false;
                        // Reduce stamina for jumping
                        playerStamina = Math.max(0, playerStamina - jumpStaminaCost);
                        updateStaminaBar();
                        
                        // If stamina is depleted, disable running
                        if (playerStamina === 0) {
                            isStaminaDepleted = true;
                            isRunning = false;
                        }
                    }
                    break;
                case 'KeyF': toggleFlashlight(); break;
                case 'ControlLeft': 
                    // Toggle crouching state instead of setting it to true
                    isCrouching = !isCrouching; 
                    document.getElementById('stealthIndicator').style.display = isCrouching ? 'block' : 'none';
                    
                    // Set or clear crouch start time
                    if (isCrouching) {
                        crouchStartTime = performance.now();
                    } else {
                        isHealing = false;
                        document.getElementById('healingIndicator').style.display = 'none';
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            if (gameOver || gameWon || !gameStarted) return;
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
                // Remove the ControlLeft case since we're using toggle now
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateEnemies(time, delta) {
            // Update regular enemy
            updateEnemy(time, delta);
            
            // Update light-sensitive enemy
            updateLightSensitiveEnemy(time, delta);
        }

        function updateEnemy(time, delta) {
            if (gameOver || gameWon) return;
            const playerPos = controls.getObject().position;
            const enemyPos = enemy.position;
            
            // Calculate base detection range
            let detectionRange = 150;
            
            // Reduce detection range if player is crouching
            if (isCrouching) {
                detectionRange = 30; // Much shorter detection when crouching
            }
            
            const distanceToPlayer = playerPos.distanceTo(enemyPos);
            
            // Update patrol point if needed
            if (time - enemy.userData.patrolTimer > enemy.userData.patrolDelay) {
                updatePatrolPoint(enemy, playerPos);
                enemy.userData.patrolTimer = time;
            }
            
            // Animate monster - add creepy pulsating effect
            enemy.userData.pulsateOffset += delta * 2; // Speed of pulsation
            const pulseFactor = Math.sin(enemy.userData.pulsateOffset) * 0.1 + 1; // 10% size pulsation
            enemy.scale.set(pulseFactor, pulseFactor, pulseFactor);
            
            // Animate legs for walking motion
            const legSpeed = enemyVelocity.length() * 20; // Leg movement speed based on velocity
            // Only animate if enemy is moving
            if (legSpeed > 0.01) {
                // Get all leg meshes
                enemy.children.forEach(child => {
                    if (child.userData && (child.userData.isLeftLeg !== undefined)) {
                        const legIndex = child.userData.legIndex;
                        const isLeft = child.userData.isLeftLeg;
                        const offset = legIndex * 0.5; // Phase offset for each leg pair
                        
                        // Calculate leg angle based on movement
                        const legAngle = Math.sin(time * 0.01 * legSpeed + offset) * 0.2; // Leg swing amount
                        // Left and right legs move opposite to each other
                        const angle = isLeft ? Math.PI / 4 + legAngle : -Math.PI / 4 - legAngle;
                        
                        // Apply leg rotation
                        child.rotation.z = angle;
                    }
                });
            }
            
            // Make eyes flash when getting close to player
            const eyeFlashSpeed = Math.max(0.1, 5 - distanceToPlayer / 30); // Flash faster as player gets closer
            enemy.userData.eyeFlashTimer += delta * eyeFlashSpeed;
            
            const eyeIntensity = (Math.sin(enemy.userData.eyeFlashTimer * 5) * 0.5 + 0.5) * (1 - distanceToPlayer / 150);
            // Find the eye meshes
            enemy.children.forEach(child => {
                if (child.material && child.material.color && child.material.color.r === 1 && 
                    child.material.color.g === 0 && child.material.color.b === 0) {
                    // It's an eye - update its intensity and size
                    child.material.opacity = 0.6 + eyeIntensity * 0.4;
                    child.scale.set(
                        1 + eyeIntensity * 0.3, 
                        1 + eyeIntensity * 0.3, 
                        1 + eyeIntensity * 0.3
                    );
                }
            });
            
            // Animate mouth to "chomp" when close to player
            if (distanceToPlayer < 30) {
                enemy.userData.mouthAnimTimer += delta * 4; // Speed of mouth animation
                const mouthOpen = Math.abs(Math.sin(enemy.userData.mouthAnimTimer * 2)); // 0 to 1 mouth open value
                
                // Find mouth and teeth
                enemy.children.forEach(child => {
                    // Find upper teeth by their rotation.x value
                    if (child.geometry && child.geometry.type === "ConeGeometry" && 
                        child.rotation.x === Math.PI) {
                        // Move upper teeth up when mouth opens
                        child.position.y = 4.25 + mouthOpen * 0.3;
                    }
                    // Find lower teeth
                    else if (child.geometry && child.geometry.type === "ConeGeometry" && 
                             child.rotation.x === 0) {
                        // Move lower teeth down when mouth opens
                        child.position.y = 3.75 - mouthOpen * 0.3;
                    }
                    // Find mouth box
                    else if (child.geometry && child.geometry.type === "BoxGeometry" && 
                             child.position.z > 2) {
                        // Make mouth taller when open
                        child.scale.set(1, 1 + mouthOpen * 2, 1);
                    }
                });
            }
            
            // Add ground shadow effect that intensifies when player is near
            const shadowIntensity = Math.min(1, 30 / distanceToPlayer);
            const particleOpacity = 0.3 + shadowIntensity * 0.4;
            
            // Find the ground particle effect
            enemy.children.forEach(child => {
                if (child.geometry && child.geometry.type === "PlaneGeometry") {
                    child.material.opacity = particleOpacity;
                    // Make the shadow pulse faster when player is closer
                    const pulseScale = 1 + Math.sin(time * 0.005 * (1 + shadowIntensity)) * 0.2;
                    child.scale.set(pulseScale * 10, pulseScale * 2, 1);
                }
            });
            
            // Check if enemy is in attack cooldown
            if (enemyAttackCooldown) {
                // During cooldown, move away from player slightly
                const direction = new THREE.Vector3()
                    .subVectors(enemyPos, playerPos)
                    .normalize();
                
                enemyVelocity.x = direction.x * 4 * delta;
                enemyVelocity.z = direction.z * 4 * delta;
                
                // During cooldown, enemy should look "exhausted"
                enemy.rotation.x = Math.sin(time * 0.01) * 0.1; // Slight forward/backward swaying
                
                // End cooldown after 4 seconds
                if (time - lastDamageTime > 4000) {
                    enemyAttackCooldown = false;
                    // Reset enemy orientation
                    enemy.rotation.x = 0;
                }
            } 
            // Directly chase player if very close or within detection range
            else if (distanceToPlayer < detectionRange) {
                // Calculate direction to player
                const direction = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize();
                
                // Check if this is the first time the enemy has detected the player
                if (!enemy.userData.isPlayerDetected) {
                    // Play detection sound using the new function
                    playDetectionSound('monster');
                    
                    // Visual log for debugging
                    playSoundEffect('monster_nearby');
                    console.log("MONSTER DETECTED PLAYER - SOUND SHOULD PLAY NOW");
                    
                    enemy.userData.isPlayerDetected = true;
                    
                    // Make the monster look directly at the player
                    enemy.rotation.x = 0.3; // Look up slightly
                    
                    // Reset the detection flag after a while so it can trigger again later
                    setTimeout(() => {
                        enemy.userData.isPlayerDetected = false;
                    }, 15000); // Increased from 10000 to 15000ms (15 seconds)
                }
                
                // Determine enemy speed - slower base speed and reduced scaling with distance
                const baseEnemySpeed = 3 + (detectionRange - distanceToPlayer) * 0.01; // Reduced from 5 + 0.05 scaling
                
                // Cap the maximum speed to prevent it from getting too fast
                let enemySpeed = Math.min(baseEnemySpeed, 4.5); // Maximum speed cap
                
                // Add a slight slowdown when very close to the player (within 4 units)
                // This gives the player a chance to escape when the monster gets too close
                if (distanceToPlayer < 4) {
                    enemySpeed *= 0.7; // 30% slowdown when very close
                }
                
                enemyVelocity.x = direction.x * enemySpeed * delta;
                enemyVelocity.z = direction.z * enemySpeed * delta;
                
                // Make enemy lean toward direction of travel
                const targetRotationY = Math.atan2(direction.x, direction.z);
                // Smooth rotation
                const currentRotationY = enemy.rotation.y;
                enemy.rotation.y = currentRotationY + (targetRotationY - currentRotationY) * 5 * delta;
                
                // When chasing, make the enemy look more aggressive
                if (distanceToPlayer < 30) {
                    enemy.rotation.x = 0.2; // Lean forward when aggressive
                } else {
                    enemy.rotation.x = 0; // Normal posture
                }
            } 
            // Otherwise patrol toward the patrol point
            else {
                const patrolDirection = new THREE.Vector3()
                    .subVectors(enemy.userData.patrolTarget, enemyPos)
                    .normalize();
                
                const patrolSpeed = 2; // Reduced from 3 for slower patrol movement
                enemyVelocity.x = patrolDirection.x * patrolSpeed * delta;
                enemyVelocity.z = patrolDirection.z * patrolSpeed * delta;
                
                // Rotate enemy to face patrol direction
                const targetRotationY = Math.atan2(patrolDirection.x, patrolDirection.z);
                const currentRotationY = enemy.rotation.y;
                enemy.rotation.y = currentRotationY + (targetRotationY - currentRotationY) * 3 * delta;
                
                // If enemy is close to patrol point, slow down
                if (enemyPos.distanceTo(enemy.userData.patrolTarget) < 5) {
                    enemyVelocity.x *= 0.8;
                    enemyVelocity.z *= 0.8;
                }
                
                // Slight tilt during patrol for more natural movement
                enemy.rotation.x = Math.sin(time * 0.001) * 0.05;
            }
            
            enemyVelocity.y -= 9.8 * delta;
            
            // Get current terrain height at enemy position
            const currentEnemyTerrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            
            // Calculate potential next position
            const nextEnemyPosX = enemyPos.x + enemyVelocity.x;
            const nextEnemyPosZ = enemyPos.z + enemyVelocity.z;
            
            // Check terrain height at next position
            const nextEnemyTerrainHeight = getTerrainHeight(nextEnemyPosX, nextEnemyPosZ);
            
            // Only move horizontally if terrain isn't too steep
            const enemyHeightDifference = nextEnemyTerrainHeight - currentEnemyTerrainHeight;
            const maxEnemyClimbHeight = 3;
            
            if (enemyHeightDifference <= maxEnemyClimbHeight) {
                enemyPos.x = nextEnemyPosX;
                enemyPos.z = nextEnemyPosZ;
            }
            
            // Apply vertical movement with collision detection
            enemyPos.y += enemyVelocity.y * delta;
            
            // Keep enemy above terrain with buffer - adjust for larger enemy
            const enemyTerrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            const enemyHeightOffset = 2; // Enemy height above terrain
            if (enemyPos.y < enemyTerrainHeight + enemyHeightOffset) {
                enemyPos.y = enemyTerrainHeight + enemyHeightOffset;
                enemyVelocity.y = 0;
            }
            
            // Keep enemy within terrain bounds
            enemyPos.x = Math.max(-490, Math.min(490, enemyPos.x));
            enemyPos.z = Math.max(-490, Math.min(490, enemyPos.z));
            
            // Only damage player if close and enemy can "see" player and not in cooldown
            const distance = playerPos.distanceTo(enemyPos);
            if (!enemyAttackCooldown && distance < 5 && (distanceToPlayer < detectionRange) && time - lastDamageTime > 1000) {
                // Add a "lunge" animation for attack
                enemy.rotation.x = 0.5; // Lean forward aggressively
                
                // Reduce health by 20-30% depending on how aggressive the monster is
                const attackPower = 20 + Math.floor(10 * (distanceToPlayer < 30 ? 1 : 0));
                playerHealth -= attackPower;
                lastDamageTime = time;
                enemyAttackCooldown = true;
                
                // Play a terrifying sound when it attacks
                playSoundEffect('monster_attack');
                
                // Show damage effect on screen
                showDamageEffect();
                
                // Player knockback effect
                const knockbackDirection = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize()
                    .multiplyScalar(10); // Increased knockback strength
                    
                velocity.x += knockbackDirection.x;
                velocity.z += knockbackDirection.z;
                
                // Activate speed boost for 3 seconds
                speedBoostActive = true;
                speedBoostEndTime = time + 3000; // 3 seconds
                
                // Add visual indicator for speed boost
                document.getElementById('damageOverlay').style.boxShadow = 'inset 0 0 50px rgba(0, 100, 255, 0.5)';
                setTimeout(() => {
                    document.getElementById('damageOverlay').style.boxShadow = 'none';
                }, 3000);
                
                // Update health bar display
                updateHealthBar();
                
                // Check for game over
                if (playerHealth <= 0) {
                    showLoseScreen();
                }
            }
            
            // Check if speed boost should end
            if (speedBoostActive && time > speedBoostEndTime) {
                speedBoostActive = false;
            }
        }

        function createGroundMonster() {
            // Create a group to hold all parts of the monster
            enemy = new THREE.Group();
            
            // Create the main body - taller and more intimidating than a box
            const bodyGeometry = new THREE.ConeGeometry(3, 7, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x330000,
                roughness: 0.7,
                metalness: 0.2,
                emissive: 0x220000,
                emissiveIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 3.5;
            enemy.add(body);
            
            // Add spikes to the body for a more menacing look
            const spikeGeometry = new THREE.ConeGeometry(0.5, 2, 4);
            const spikeMaterial = new THREE.MeshStandardMaterial({
                color: 0x220000,
                roughness: 0.3,
                metalness: 0.7
            });
            
            // Add multiple spikes around the body
            for (let i = 0; i < 8; i++) {
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                const angle = (i / 8) * Math.PI * 2;
                const radius = 2.5;
                spike.position.set(
                    Math.cos(angle) * radius,
                    4,
                    Math.sin(angle) * radius
                );
                spike.rotation.x = Math.PI / 2;
                spike.rotation.z = -angle;
                enemy.add(spike);
            }
            
            // Create glowing red eyes
            const eyeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            
            // Add eyes to the front of the body
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-1, 5.5, 2);
            enemy.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(1, 5.5, 2);
            enemy.add(rightEye);
            
            // Add a mouth with sharp teeth
            const mouthGeometry = new THREE.BoxGeometry(2, 0.5, 1);
            const mouthMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 4, 2.5);
            enemy.add(mouth);
            
            // Add teeth
            const toothGeometry = new THREE.ConeGeometry(0.2, 0.6, 3);
            const toothMaterial = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                roughness: 0.3
            });
            
            // Add upper and lower teeth
            for (let i = 0; i < 5; i++) {
                const upperTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                upperTooth.position.set(-1 + i * 0.5, 4.25, 2.6);
                upperTooth.rotation.x = Math.PI;
                enemy.add(upperTooth);
                
                const lowerTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                lowerTooth.position.set(-1 + i * 0.5, 3.75, 2.6);
                enemy.add(lowerTooth);
            }
            
            // Add a wispy particle effect at the base for a more supernatural look
            const particleGeometry = new THREE.PlaneGeometry(10, 2);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x660000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const particles = new THREE.Mesh(particleGeometry, particleMaterial);
            particles.position.y = 0.5;
            particles.rotation.x = Math.PI / 2;
            enemy.add(particles);
            
            // Create legs for the monster
            const legGeometry = new THREE.CylinderGeometry(0.5, 0.2, 3, 4);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x330000,
                roughness: 0.9
            });
            
            // Add multiple legs for a spider-like appearance
            const legPairs = 3;
            for (let i = 0; i < legPairs; i++) {
                // Left leg
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-2.5, 1.5, (i - 1) * 1.5);
                leftLeg.rotation.z = Math.PI / 4;
                enemy.add(leftLeg);
                
                // Right leg
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(2.5, 1.5, (i - 1) * 1.5);
                rightLeg.rotation.z = -Math.PI / 4;
                enemy.add(rightLeg);
                
                // Store references to legs for animation
                leftLeg.userData = { isLeftLeg: true, legIndex: i };
                rightLeg.userData = { isLeftLeg: false, legIndex: i };
            }
            
            // Position the complete enemy
            enemy.position.set(200, 2, 200);
            
            // Add patrol and behavior data
            enemy.userData = {
                patrolRadius: 120, // Increased patrol radius
                patrolTarget: new THREE.Vector3(),
                patrolTimer: 0,
                patrolDelay: 8000, // More frequent patrol updates
                pulsateOffset: 0,  // For pulsating effect
                eyeFlashTimer: 0,  // For eye flashing effect
                mouthAnimTimer: 0,  // For mouth animation
                isPlayerDetected: false // New detection flag
            };
            
            scene.add(enemy);
            
            // Return a reference to the created enemy
            return enemy;
        }

        function createGhostEnemy() {
            // Create ghost body - more organic shape than a box
            const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
            
            // Create translucent, glowing material for ghost
            const ghostMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                emissive: 0x4466ff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.1
            });
            
            // Create the main ghost body
            lightSensitiveEnemy = new THREE.Mesh(ghostGeometry, ghostMaterial);
            lightSensitiveEnemy.position.set(-200, 5, -200); // Start higher above ground
            scene.add(lightSensitiveEnemy);
            
            // Add glowing eyes to ghost
            const eyeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                emissive: 0x00ffff, 
                emissiveIntensity: 1 
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.7, 0.7, 1.5);
            lightSensitiveEnemy.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.7, 0.7, 1.5);
            lightSensitiveEnemy.add(rightEye);
            
            // Add trailing particle effect (simplified with small meshes)
            const trailGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.5
            });
            
            // Create several trailing particles
            for (let i = 0; i < 6; i++) {
                const trail = new THREE.Mesh(trailGeometry, trailMaterial.clone());
                trail.material.opacity = 0.5 - (i * 0.08); // Fade out
                trail.scale.set(1 - (i * 0.1), 1 - (i * 0.1), 1 - (i * 0.1)); // Get smaller
                trail.position.set(0, -i * 0.5, -i * 0.5); // Position behind
                trail.userData = {
                    offset: i,
                    originalOpacity: 0.5 - (i * 0.08)
                };
                lightSensitiveEnemy.add(trail);
            }
            
            // Add patrol data to ghost enemy - closer patrol radius (70 instead of 150)
            lightSensitiveEnemy.userData = {
                patrolRadius: 70, // Reduced patrol radius to stay closer to player
                patrolTarget: new THREE.Vector3(),
                patrolTimer: 5000, // Offset patrol timing from other enemy
                patrolDelay: 8000, // Reduced delay - update patrol points more frequently
                floatOffset: 0,    // For floating animation
                floatSpeed: 1 + Math.random() * 0.5, // Random float speed
                aggressiveMode: false, // Track if ghost is in aggressive mode
                isPlayerDetected: false // New detection flag
            };
        }

        function updateGhostAppearance(isInLight) {
            // Make ghost more visible and aggressive looking when in light
            lightSensitiveEnemy.userData.aggressiveMode = isInLight;
            
            if (isInLight) {
                // Brighten the ghost when exposed to light and make it red-tinted
                lightSensitiveEnemy.material.emissiveIntensity = 1.5;
                lightSensitiveEnemy.material.opacity = 0.9;
                lightSensitiveEnemy.material.emissive.set(0xff4466); // More reddish when aggressive
                
                // Make eyes glow bright red
                lightSensitiveEnemy.children[0].material.color.set(0xff0000);
                lightSensitiveEnemy.children[1].material.color.set(0xff0000);
                lightSensitiveEnemy.children[0].material.emissiveIntensity = 5; // Brighter eyes
                lightSensitiveEnemy.children[1].material.emissiveIntensity = 5;
                
                // Scale up slightly when aggressive
                lightSensitiveEnemy.scale.set(1.3, 1.3, 1.3);
                
                // Make trails more visible and reddish
                for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                    const trail = lightSensitiveEnemy.children[i];
                    trail.material.opacity = trail.userData.originalOpacity * 2;
                    trail.material.color.set(0xff6688);
                }
            } else {
                // Make ghost more translucent and subtle when not in light
                lightSensitiveEnemy.material.emissiveIntensity = 0.5;
                lightSensitiveEnemy.material.opacity = 0.7;
                lightSensitiveEnemy.material.emissive.set(0x4466ff); // Blue when calm
                
                // Dim the eyes and return to cyan
                lightSensitiveEnemy.children[0].material.color.set(0x00ffff);
                lightSensitiveEnemy.children[1].material.color.set(0x00ffff);
                lightSensitiveEnemy.children[0].material.emissiveIntensity = 1;
                lightSensitiveEnemy.children[1].material.emissiveIntensity = 1;
                
                // Normal size when calm
                lightSensitiveEnemy.scale.set(1, 1, 1);
                
                // Make trails less visible and blue again
                for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                    const trail = lightSensitiveEnemy.children[i];
                    trail.material.opacity = trail.userData.originalOpacity;
                    trail.material.color.set(0x88ccff);
                }
            }
        }

        function updateGhostTrails(position, previousPosition) {
            // Update ghost trails to follow behind with a delay
            for (let i = 2; i < lightSensitiveEnemy.children.length; i++) {
                const trail = lightSensitiveEnemy.children[i];
                const trailOffset = trail.userData.offset;
                
                // Calculate direction vector from current to previous position
                const directionX = previousPosition.x - position.x;
                const directionZ = previousPosition.z - position.z;
                
                // Position trail along this vector
                const distanceFactor = 0.5 * trailOffset;
                trail.position.x = directionX * distanceFactor;
                trail.position.z = directionZ * distanceFactor;
                
                // Fade trail opacity based on movement speed
                const speed = Math.sqrt(directionX * directionX + directionZ * directionZ);
                trail.material.opacity = Math.min(
                    trail.userData.originalOpacity * (1 + speed * 2),
                    0.6
                );
            }
        }

        function updateLightSensitiveEnemy(time, delta) {
            if (gameOver || gameWon) return;
            const playerPos = controls.getObject().position;
            const enemyPos = lightSensitiveEnemy.position;
            const previousPos = enemyPos.clone(); // Store position to calculate trail effects
            
            // Calculate base detection range - default is very low
            let detectionRange = 30; // Increased base detection from 20 to 30
            let isInLight = false;
            
            // If flashlight is on, detection range increases dramatically
            if (isFlashlightOn) {
                // Calculate angle between flashlight direction and enemy
                const flashlightDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const toEnemyDirection = new THREE.Vector3().subVectors(enemyPos, playerPos).normalize();
                
                // Dot product tells us if enemy is in flashlight cone
                const dotProduct = flashlightDirection.dot(toEnemyDirection);
                
                // If enemy is in flashlight cone (front of player) and within 50 units
                const distanceToPlayer = playerPos.distanceTo(enemyPos);
                if (dotProduct > 0.7 && distanceToPlayer < 60) { // Increased detection range to 60
                    detectionRange = 200; // Greatly increased detection
                    isInLight = true;
                }
            }
            
            // Update ghost appearance based on if it's in light
            updateGhostAppearance(isInLight);
            
            // Add floating movement to ghost (independent of patrol)
            lightSensitiveEnemy.userData.floatOffset += delta * lightSensitiveEnemy.userData.floatSpeed;
            // More erratic floating when aggressive
            const floatAmplitude = isInLight ? 2.5 : 1.5;
            const floatHeight = Math.sin(lightSensitiveEnemy.userData.floatOffset) * floatAmplitude;
            
            // Reduce detection range if player is crouching
            if (isCrouching) {
                detectionRange *= 0.5; // Half the detection range when crouching
            }
            
            const distanceToPlayer = playerPos.distanceTo(enemyPos);
            
            // Update patrol point if needed
            if (time - lightSensitiveEnemy.userData.patrolTimer > lightSensitiveEnemy.userData.patrolDelay) {
                updatePatrolPoint(lightSensitiveEnemy, playerPos);
                lightSensitiveEnemy.userData.patrolTimer = time;
            }
            
            // Check if enemy is in attack cooldown
            if (lightEnemyAttackCooldown) {
                // During cooldown, move away from player slightly
                const direction = new THREE.Vector3()
                    .subVectors(enemyPos, playerPos)
                    .normalize();
                
                lightEnemyVelocity.x = direction.x * 4 * delta;
                lightEnemyVelocity.z = direction.z * 4 * delta;
                
                // End cooldown after 4 seconds
                if (time - lastDamageTime > 4000) {
                    lightEnemyAttackCooldown = false;
                    lightSensitiveEnemy.material.emissive.set(0x4466ff); // Reset emissive color
                }
            } 
            // Only chase if within detection range and not in cooldown
            else if (distanceToPlayer < detectionRange) {
                const direction = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize();
                
                // Check if this is the first time the ghost has detected the player
                if (!lightSensitiveEnemy.userData.isPlayerDetected) {
                    // Play ghost detection sound using the new function
                    playDetectionSound('ghost');
                    
                    // Visual log for debugging
                    playSoundEffect('ghost_moan');
                    console.log("GHOST DETECTED PLAYER - SOUND SHOULD PLAY NOW");
                    
                    lightSensitiveEnemy.userData.isPlayerDetected = true;
                    
                    // Reset the detection flag after a while so it can trigger again later
                    setTimeout(() => {
                        lightSensitiveEnemy.userData.isPlayerDetected = false;
                    }, 12000); // 12 seconds cooldown
                }
                
                // Light sensitive enemy moves faster when it detects flashlight
                let enemySpeed = isInLight ? 15 : 6; // Increased speeds (was 10/4)
                
                // Add some randomness to movement when aggressive for more erratic behavior
                if (isInLight) {
                    direction.x += (Math.random() - 0.5) * 0.3;
                    direction.z += (Math.random() - 0.5) * 0.3;
                    direction.normalize(); // Re-normalize after adding randomness
                }
                
                lightEnemyVelocity.x = direction.x * enemySpeed * delta;
                lightEnemyVelocity.z = direction.z * enemySpeed * delta;
            } 
            // Otherwise patrol toward the patrol point
            else {
                const patrolDirection = new THREE.Vector3()
                    .subVectors(lightSensitiveEnemy.userData.patrolTarget, enemyPos)
                    .normalize();
                
                // Ghost moves faster in patrol mode to keep up with player
                const patrolSpeed = 4; // Increased from 2 to 4
                lightEnemyVelocity.x = patrolDirection.x * patrolSpeed * delta;
                lightEnemyVelocity.z = patrolDirection.z * patrolSpeed * delta;
                
                // If enemy is close to patrol point, slow down
                if (enemyPos.distanceTo(lightSensitiveEnemy.userData.patrolTarget) < 5) {
                    lightEnemyVelocity.x *= 0.8;
                    lightEnemyVelocity.z *= 0.8;
                }
            }
            
            // Apply horizontal movement (no need for terrain collision since ghost floats)
            enemyPos.x += lightEnemyVelocity.x;
            enemyPos.z += lightEnemyVelocity.z;
            
            // Apply floating movement - hover above the terrain
            const terrainHeight = getTerrainHeight(enemyPos.x, enemyPos.z);
            enemyPos.y = terrainHeight + 5 + floatHeight; // Float 5 units above terrain + sine wave
            
            // Keep enemy within terrain bounds
            enemyPos.x = Math.max(-490, Math.min(490, enemyPos.x));
            enemyPos.z = Math.max(-490, Math.min(490, enemyPos.z));
            
            // Update ghost trails
            updateGhostTrails(enemyPos, previousPos);
            
            // Only damage player if close and enemy can "see" player and not in cooldown
            const distance = playerPos.distanceTo(enemyPos);
            if (!lightEnemyAttackCooldown && distance < 5 && (distanceToPlayer < detectionRange) && time - lastDamageTime > 1000) {
                // Reduce health by 20%, more when ghost is aggressive
                const damage = isInLight ? 30 : 20; // More damage when aggressive
                playerHealth -= damage;
                lastDamageTime = time;
                lightEnemyAttackCooldown = true;
                
                // Visual indicator for enemy attack cooldown - change emissive color
                lightSensitiveEnemy.material.emissive.set(0x00ff00);
                
                // Show damage effect on screen
                showDamageEffect();
                
                // Player knockback effect - stronger when ghost is aggressive
                const knockbackStrength = isInLight ? 15 : 10;
                const knockbackDirection = new THREE.Vector3()
                    .subVectors(playerPos, enemyPos)
                    .normalize()
                    .multiplyScalar(knockbackStrength);
                    
                velocity.x += knockbackDirection.x;
                velocity.z += knockbackDirection.z;
                
                // Activate speed boost for 3 seconds
                speedBoostActive = true;
                speedBoostEndTime = time + 3000; // 3 seconds
                
                // Add visual indicator for speed boost
                document.getElementById('damageOverlay').style.boxShadow = 'inset 0 0 50px rgba(0, 100, 255, 0.5)';
                setTimeout(() => {
                    document.getElementById('damageOverlay').style.boxShadow = 'none';
                }, 3000);
                
                // Play damage sound
                playSoundEffect('damage');
                
                // Update health bar display
                updateHealthBar();
                
                // Check for game over
                if (playerHealth <= 0) {
                    showLoseScreen();
                }
            }
        }

        function updatePatrolPoint(enemyObject, playerPos) {
            // Generate a random point within the patrol radius of the player
            const angle = Math.random() * Math.PI * 2;
            const minDistance = 50; // Minimum distance from player
            const patrolRadius = enemyObject.userData.patrolRadius;
            
            // For ghost enemy, reduce minimum distance to make it patrol closer
            const actualMinDistance = (enemyObject === lightSensitiveEnemy) ? 30 : minDistance;
            
            const distance = actualMinDistance + Math.random() * (patrolRadius - actualMinDistance);
            
            // Calculate patrol coordinates
            const targetX = playerPos.x + Math.cos(angle) * distance;
            const targetZ = playerPos.z + Math.sin(angle) * distance;
            
            // Clamp to terrain bounds
            const clampedX = Math.max(-490, Math.min(490, targetX));
            const clampedZ = Math.max(-490, Math.min(490, targetZ));
            
            // Get terrain height at target position
            const targetY = getTerrainHeight(clampedX, clampedZ) + 2;
            
            // Set new patrol target
            enemyObject.userData.patrolTarget.set(clampedX, targetY, clampedZ);
        }

        function updateHealthBar() {
            const healthElement = document.getElementById('health');
            // Ensure health is between 0 and 100
            playerHealth = Math.max(0, Math.min(100, playerHealth));
            healthElement.style.width = `${playerHealth}%`;
            
            // Update health bar color based on health percentage
            if (playerHealth > 60) {
                healthElement.style.background = '#00ff00'; // Green
            } else if (playerHealth > 30) {
                healthElement.style.background = '#ffff00'; // Yellow
            } else {
                healthElement.style.background = '#ff0000'; // Red
            }
            
            console.log(`Player health: ${playerHealth}%`); // Debug output
        }

        function showDamageEffect() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'rgba(255, 0, 0, 0.3)';
            
            setTimeout(() => {
                overlay.style.background = 'rgba(255, 0, 0, 0)';
            }, 300);
        }
        
        function showHealingEffect() {
            // Add a green pulse to the damage overlay
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'rgba(0, 255, 0, 0.1)';
            
            setTimeout(() => {
                overlay.style.background = 'rgba(0, 255, 0, 0)';
            }, 200);
        }
        
        function playSoundEffect(type) {
            // Sound effect logging with more specific sound types
            const soundDescriptions = {
                'damage': 'Player damage impact sound',
                'collect': 'Crystal collection chime',
                'monster_attack': 'Terrifying monster roar mixed with growls',
                'monster_nearby': 'Deep, unsettling breathing and growling',
                'ghost_attack': 'High-pitched supernatural screech',
                'ghost_moan': 'Low-pitched ghostly moan'
            };
            
            const description = soundDescriptions[type] || `Unknown sound: ${type}`;
            console.log(`Sound effect: ${description}`);
        }

        function showLoseScreen() {
            gameOver = true;
            document.getElementById('loseScreen').style.display = 'flex';
            document.getElementById('info').style.display = 'none';
            controls.unlock();
            
            // We'll keep the gameplay music running during the lose screen
            // This creates continuity rather than sudden silence
        }

        function restartGame() {
            gameOver = false;
            gameWon = false;
            
            // Use our more comprehensive reset function
            resetGame();
            
            // Handle UI elements
            document.getElementById('loseScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('stealthIndicator').style.display = 'none';
            document.getElementById('healingIndicator').style.display = 'none';
            document.getElementById('flashlightIndicator').style.display = isFlashlightOn ? 'block' : 'none';
            document.getElementById('collectionCounter').style.display = 'block';
            document.getElementById('healthBar').style.display = 'block';
            document.getElementById('staminaBar').style.display = 'block';
            document.getElementById('damageOverlay').style.background = 'rgba(255, 0, 0, 0)';
            document.getElementById('damageOverlay').style.boxShadow = 'none';
            
            // Reset gameplay music
            if (gameplayAudio) {
                gameplayAudio.currentTime = 0; // Start from beginning
                if (!gameplayAudio.paused) {
                    // If music was on, restart it
                    gameplayAudio.play().catch(e => {
                        console.log("Couldn't restart gameplay music: ", e);
                    });
                }
            }
            
            // Recreate collectibles
            collectibles.forEach(crystal => {
                if (crystal && scene.getObjectById(crystal.id)) {
                    scene.remove(crystal);
                }
            });
            createCollectibles(totalCollectibles);
            
            if (!gameStarted) {
                startGame();
            } else {
                controls.lock();
            }
        }

        function setupFlashlight() {
            // Create a spotlight
            flashlight = new THREE.SpotLight(0xffffff, 1, 50, Math.PI / 6, 0.5, 2);
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            flashlight.visible = false; // Off by default
            
            // Add the light and its target to the scene
            scene.add(flashlight);
            scene.add(flashlight.target);
            
            // Optional: Add helper to visualize light direction (uncomment for debugging)
            // flashlightHelper = new THREE.SpotLightHelper(flashlight);
            // scene.add(flashlightHelper);
        }

        function toggleFlashlight() {
            isFlashlightOn = !isFlashlightOn;
            flashlight.visible = isFlashlightOn;
            document.getElementById('flashlightIndicator').style.display = isFlashlightOn ? 'block' : 'none';
        }

        function updateFlashlightPosition() {
            if (!flashlight) return;
            
            // Get camera position and direction
            const cameraPosition = controls.getObject().position.clone();
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Position the flashlight slightly below the camera (as if held in hand)
            flashlight.position.copy(cameraPosition);
            flashlight.position.y -= 0.5;
            
            // Set the target position in front of the camera
            const targetPosition = cameraPosition.clone().add(cameraDirection.multiplyScalar(10));
            flashlight.target.position.copy(targetPosition);
            
            // Update helper if it exists
            if (flashlightHelper) flashlightHelper.update();
        }

        function createCollectibles(count) {
            // Create a crystal geometry
            const crystalGeometry = new THREE.OctahedronGeometry(1, 0);
            
            // Create base material (dim when not illuminated)
            const crystalMaterial = new THREE.MeshStandardMaterial({
                color: 0x77ccff,
                emissive: 0x4477aa,
                emissiveIntensity: 0.2,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            // Clear existing collectibles array if restarting
            collectibles = [];
            
            // Create crystals and place them around the map
            for (let i = 0; i < count; i++) {
                // Random position, but spread out from center
                const angle = (i / count) * Math.PI * 2; // Distribute around a circle
                const radius = 100 + Math.random() * 300; // Random radius between 100-400 units
                
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                
                // Get terrain height at position
                const y = getTerrainHeight(x, z);
                
                // Create crystal
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial.clone());
                crystal.position.set(x, y + 1.5, z); // Position slightly above terrain
                crystal.rotation.set(Math.random(), Math.random(), Math.random()); // Random rotation
                crystal.scale.set(1, 1.5, 1); // Make slightly taller
                
                // Add random rotation animation
                crystal.userData = {
                    rotationSpeed: 0.005 + Math.random() * 0.01,
                    illuminated: false,
                    collected: false,
                    originalY: y + 1.5,
                    floatOffset: 0
                };
                
                scene.add(crystal);
                collectibles.push(crystal);
            }
        }

        function updateCollectibles(time) {
            if (gameOver || gameWon) return;
            
            const playerPos = controls.getObject().position;
            
            // Get flashlight direction for testing if crystals are illuminated
            const flashlightDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Update each collectible
            collectibles.forEach(crystal => {
                if (crystal.userData.collected) return;
                
                // Animated floating effect
                crystal.userData.floatOffset = Math.sin(time * 0.001) * 0.2;
                crystal.position.y = crystal.userData.originalY + crystal.userData.floatOffset;
                
                // Rotate crystal
                crystal.rotation.y += crystal.userData.rotationSpeed;
                
                // Check if crystal is in flashlight beam
                const crystalPos = crystal.position;
                const toCollectibleDirection = new THREE.Vector3().subVectors(crystalPos, playerPos).normalize();
                const dotProduct = flashlightDirection.dot(toCollectibleDirection);
                const distanceToPlayer = playerPos.distanceTo(crystalPos);
                
                const inFlashlightBeam = isFlashlightOn && dotProduct > 0.8 && distanceToPlayer < 50;
                
                // Illuminate crystal if in flashlight beam
                if (inFlashlightBeam && !crystal.userData.illuminated) {
                    crystal.material.emissiveIntensity = 1.5;
                    crystal.userData.illuminated = true;
                } else if (!inFlashlightBeam && crystal.userData.illuminated) {
                    crystal.material.emissiveIntensity = 0.2;
                    crystal.userData.illuminated = false;
                }
                
                // Check for collection (player can only collect illuminated crystals when close)
                if (crystal.userData.illuminated && distanceToPlayer < 5) {
                    collectCrystal(crystal);
                }
            });
        }

        function collectCrystal(crystal) {
            crystal.userData.collected = true;
            scene.remove(crystal);
            
            // Play collection sound
            playSoundEffect('collect');
            
            // Increment collection counter
            collectedCount++;
            updateCollectibleCounter();
            
            // Check for win condition
            if (collectedCount >= totalCollectibles) {
                showWinScreen();
            }
        }

        function updateCollectibleCounter() {
            document.getElementById('collectionCounter').innerText = `CRYSTALS: ${collectedCount}/${totalCollectibles}`;
        }

        function showWinScreen() {
            gameWon = true;
            document.getElementById('winScreen').style.display = 'flex';
            document.getElementById('info').style.display = 'none';
            controls.unlock();
            
            // We'll keep the gameplay music running during the win screen
            // This creates continuity rather than sudden silence
        }

        function updateStaminaBar() {
            const staminaElement = document.getElementById('stamina');
            staminaElement.style.width = `${playerStamina}%`;
            
            // Change color based on stamina level
            if (playerStamina > 60) {
                staminaElement.style.background = '#ffcc00'; // Yellow-orange
            } else if (playerStamina > 30) {
                staminaElement.style.background = '#ff8800'; // Orange
            } else {
                staminaElement.style.background = '#ff3300'; // Red-orange
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Animate skybox stars - do this regardless of game state
            if (scene.getObjectByProperty('type', 'Mesh')) {
                // Find the skybox
                scene.children.forEach(child => {
                    if (child.userData && child.userData.animateStars) {
                        child.userData.animateStars(time);
                    }
                });
            }

            if (!gameOver && !gameWon && gameStarted) {
                // Update flashlight position
                updateFlashlightPosition();
                
                // Update collectibles (animation, illumination, collection)
                updateCollectibles(time);
                
                // No longer need tree billboards since we use simple trees
                
                // Check for healing conditions - player must be crouched and stationary for a period
                if (isCrouching && playerHealth < 100) {
                    // Check if player is mostly stationary
                    const isStationary = Math.abs(velocity.x) < 0.1 && Math.abs(velocity.z) < 0.1;
                    
                    if (isStationary && time - crouchStartTime > requiredCrouchTimeForHealing) {
                        // Start healing
                        if (!isHealing) {
                            isHealing = true;
                            document.getElementById('healingIndicator').style.display = 'block';
                        }
                        
                        // Apply healing at intervals
                        if (time - lastHealTime > healingInterval) {
                            playerHealth = Math.min(100, playerHealth + healAmount);
                            lastHealTime = time;
                            updateHealthBar();
                            
                            // Add healing particles or effects
                            showHealingEffect();
                        }
                    } else {
                        // If moving or not crouched long enough, stop healing
                        if (isHealing) {
                            isHealing = false;
                            document.getElementById('healingIndicator').style.display = 'none';
                        }
                    }
                }
                
                // Handle stamina regeneration/depletion
                if (isRunning && !isCrouching) {
                    // Drain stamina while running
                    playerStamina = Math.max(0, playerStamina - runningStaminaDrain * delta);
                    
                    // If stamina is fully depleted, disable running until recharged to 30%
                    if (playerStamina === 0) {
                        isStaminaDepleted = true;
                        isRunning = false;
                    }
                } else {
                    // Regenerate stamina when not running
                    playerStamina = Math.min(100, playerStamina + staminaRegenRate * delta);
                    
                    // If stamina is recharged enough, allow running again
                    if (isStaminaDepleted && playerStamina > 30) {
                        isStaminaDepleted = false;
                    }
                }
                
                // Update stamina bar
                updateStaminaBar();
                
                velocity.y -= 9.8 * delta;
                
                // Adjust speed based on running/crouching state
                let speed = 150; // Normal speed
                if (isRunning && !isCrouching && !isStaminaDepleted) {
                    speed = 300; // Running speed
                } else if (isCrouching) {
                    speed = 70; // Slower when crouching
                }
                
                // Apply speed boost if active
                if (speedBoostActive) {
                    speed *= 1.5; // 50% speed boost
                }

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(controls.getObject().quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(controls.getObject().quaternion);

                const direction = new THREE.Vector3();
                if (moveForward) direction.add(forward);
                if (moveBackward) direction.sub(forward);
                if (moveRight) direction.add(right);
                if (moveLeft) direction.sub(right);

                if (direction.length() > 0) {
                    direction.normalize().multiplyScalar(speed * delta);
                    velocity.x = direction.x;
                    velocity.z = direction.z;
                } else {
                    velocity.x *= 0.9;
                    velocity.z *= 0.9;
                }

                // Current position
                const pos = controls.getObject().position;
                const currentHeight = getTerrainHeight(pos.x, pos.z);
                
                // Sample multiple points around the player for better collision detection
                const samplePoints = [
                    {x: 0, z: 1},   // front
                    {x: 0, z: -1},  // back
                    {x: 1, z: 0},   // right
                    {x: -1, z: 0},  // left
                    {x: 0.7, z: 0.7},   // front-right
                    {x: -0.7, z: 0.7},  // front-left
                    {x: 0.7, z: -0.7},  // back-right
                    {x: -0.7, z: -0.7}  // back-left
                ];
                
                // Calculate potential next position
                const nextPosX = pos.x + velocity.x * delta;
                const nextPosZ = pos.z + velocity.z * delta;
                
                // Check if any sampled point would clip into terrain
                let canMoveX = true;
                let canMoveZ = true;
                const playerRadius = 1;
                
                for (const point of samplePoints) {
                    // Check X movement
                    const sampleX = nextPosX + point.x * playerRadius;
                    const sampleCurrentZ = pos.z + point.z * playerRadius;
                    const heightX = getTerrainHeight(sampleX, sampleCurrentZ);
                    
                    // Check Z movement
                    const sampleCurrentX = pos.x + point.x * playerRadius;
                    const sampleZ = nextPosZ + point.z * playerRadius;
                    const heightZ = getTerrainHeight(sampleCurrentX, sampleZ);
                    
                    // Calculate height differences
                    const diffX = heightX - currentHeight;
                    const diffZ = heightZ - currentHeight;
                    
                    // Maximum height player can climb
                    const maxClimbableHeight = 2;
                    
                    // Update movement flags
                    if (diffX > maxClimbableHeight) canMoveX = false;
                    if (diffZ > maxClimbableHeight) canMoveZ = false;
                }
                
                // Apply movement with collision detection
                if (canMoveX) {
                    controls.getObject().position.x = nextPosX;
                }
                
                if (canMoveZ) {
                    controls.getObject().position.z = nextPosZ;
                }
                
                // Apply vertical movement
                controls.getObject().position.y += velocity.y * delta;
                
                // Get terrain height at current position for ground collision
                const terrainHeight = getTerrainHeight(
                    controls.getObject().position.x, 
                    controls.getObject().position.z
                );
                
                // Set player height based on crouching state with a buffer to prevent clipping
                const playerHeightOffset = isCrouching ? crouchHeight : normalHeight;
                
                // Apply ground collision with better buffer
                if (controls.getObject().position.y < terrainHeight + playerHeightOffset + 0.2) {
                    controls.getObject().position.y = terrainHeight + playerHeightOffset + 0.2;
                    velocity.y = 0;
                    canJump = true;
                }

                // Keep player within terrain bounds
                pos.x = Math.max(-490, Math.min(490, pos.x));
                pos.z = Math.max(-490, Math.min(490, pos.z));

                // Update both enemies
                updateEnemies(time, delta);
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // Add this function after init() but before animate()
        function setupMainMenuAudio() {
            // Create audio element for menu
            window.menuAudio = new Audio('Whispers in the Pines.mp3');
            window.menuAudio.loop = true;
            window.menuAudio.volume = 0.5;
            
            // Create gameplay audio element
            gameplayAudio = new Audio('MyVeryOwnDeadShip.ogg');
            gameplayAudio.loop = true;
            gameplayAudio.volume = 0.4; // Slightly lower volume for gameplay
            
            // Create enemy detection sound effects - with preloading
            console.log("Setting up detection sound effects...");
            
            monsterDetectSfx = new Audio();
            monsterDetectSfx.src = 'Monster SFX.ogg';
            monsterDetectSfx.volume = 1.0; // Full volume for detection sounds
            monsterDetectSfx.preload = 'auto'; // Ensure preloading
            
            ghostDetectSfx = new Audio();
            ghostDetectSfx.src = 'quboodup-GhostMoan03.mp3';
            ghostDetectSfx.volume = 1.0; // Full volume for detection sounds
            ghostDetectSfx.preload = 'auto'; // Ensure preloading
            
            // Force loading the detection sounds
            monsterDetectSfx.load();
            ghostDetectSfx.load();
            
            // Listen for loading completion
            monsterDetectSfx.addEventListener('canplaythrough', () => {
                console.log("Monster detection sound loaded successfully");
            });
            
            ghostDetectSfx.addEventListener('canplaythrough', () => {
                console.log("Ghost detection sound loaded successfully");
            });
            
            // Listen for errors
            const handleAudioError = (event) => {
                console.error("Error loading audio file:", event.target.src);
                console.error("Please check that the file exists at the correct path");
            };
            
            monsterDetectSfx.addEventListener('error', handleAudioError);
            ghostDetectSfx.addEventListener('error', handleAudioError);
            
            // Create play button that will be displayed if autoplay is blocked
            const musicBtn = document.createElement('button');
            musicBtn.innerHTML = "🔊 MUSIC ON";
            musicBtn.className = "music-btn";
            musicBtn.id = "musicButton";
            
            // Add button to page
            document.body.appendChild(musicBtn);
            
            // Setup click handler for music button - now controls both menu and gameplay music
            musicBtn.addEventListener('click', function() {
                if (gameStarted) {
                    // In gameplay, control gameplay music
                    if (gameplayAudio.paused) {
                        gameplayAudio.play();
                        this.innerHTML = "🔊 MUSIC ON";
                    } else {
                        gameplayAudio.pause();
                        this.innerHTML = "🔊 MUSIC OFF";
                    }
                } else {
                    // In menu, control menu music
                    if (window.menuAudio.paused) {
                        window.menuAudio.play();
                        this.innerHTML = "🔊 MUSIC ON";
                    } else {
                        window.menuAudio.pause();
                        this.innerHTML = "🔊 MUSIC OFF";
                    }
                }
            });
            
            // Try to play menu audio (might be blocked by browser policies)
            const playPromise = window.menuAudio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Autoplay prevented. User interaction required to play audio.");
                    // Keep button visible if autoplay is blocked
                });
            }
            
            // When the document is clicked anywhere, also try to play the appropriate music
            document.addEventListener('click', function audioClickHandler() {
                if (gameStarted) {
                    // Try to play gameplay music if we're in the game
                    if (gameplayAudio && gameplayAudio.paused) {
                        gameplayAudio.play();
                        const musicButton = document.getElementById('musicButton');
                        if (musicButton) {
                            musicButton.innerHTML = "🔊 MUSIC ON";
                        }
                    }
                } else {
                    // Try to play menu music if we're in the menu
                    if (window.menuAudio && window.menuAudio.paused) {
                        window.menuAudio.play();
                        const musicButton = document.getElementById('musicButton');
                        if (musicButton) {
                            musicButton.innerHTML = "🔊 MUSIC ON";
                        }
                    }
                }
            }, { once: false });
            
            return window.menuAudio;
        }

        // Create a dark starry night skybox
        function createSkybox() {
            // Create a large sphere to serve as the sky
            const skyGeometry = new THREE.SphereGeometry(900, 32, 32); // Large radius to encompass the entire scene
            
            // Create stars for the skybox
            const starsCanvas = document.createElement('canvas');
            starsCanvas.width = 1024;
            starsCanvas.height = 1024;
            const starsCtx = starsCanvas.getContext('2d');
            
            // Store star data for animation
            const stars = [];
            
            // Fill with very dark blue gradient
            const gradient = starsCtx.createLinearGradient(0, 0, 0, 1024);
            gradient.addColorStop(0, '#000510');
            gradient.addColorStop(0.3, '#020A1B');
            gradient.addColorStop(0.6, '#0A1020');
            gradient.addColorStop(1, '#000005');
            
            starsCtx.fillStyle = gradient;
            starsCtx.fillRect(0, 0, 1024, 1024);
            
            // Create star textures - separated for animation
            function drawStars() {
                // Clear the canvas but keep the background
                starsCtx.fillStyle = gradient;
                starsCtx.fillRect(0, 0, 1024, 1024);
                
                // Draw each star with its current opacity
                stars.forEach(star => {
                    // Apply the star's current brightness
                    starsCtx.fillStyle = `rgba(${star.r}, ${star.g}, ${star.b}, ${star.opacity})`;
                    starsCtx.shadowBlur = star.blur;
                    starsCtx.shadowColor = `rgba(${star.r}, ${star.g}, ${star.b}, ${star.opacity / 2})`;
                    
                    starsCtx.beginPath();
                    starsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    starsCtx.fill();
                });
                
                return starsCanvas;
            }
            
            // Add stars - brighter stars are rarer
            for (let i = 0; i < 2000; i++) {
                const x = Math.floor(Math.random() * 1024);
                const y = Math.floor(Math.random() * 1024);
                const size = Math.random() * 1.5; // Star size
                
                // Determine star color and brightness
                const chance = Math.random();
                let r, g, b, opacity, blur, twinkleSpeed;
                
                if (chance < 0.1) {
                    // 10% brighter stars
                    r = 255; g = 255; b = 255;
                    opacity = Math.random() * 0.8 + 0.2;
                    blur = 4;
                    // Brighter stars twinkle faster
                    twinkleSpeed = 0.5 + Math.random() * 2;
                } else if (chance < 0.2) {
                    // 10% blue-tinted stars
                    r = 200; g = 220; b = 255;
                    opacity = Math.random() * 0.6 + 0.1;
                    blur = 2;
                    twinkleSpeed = 0.3 + Math.random() * 1;
                } else if (chance < 0.25) {
                    // 5% reddish stars
                    r = 255; g = 210; b = 200;
                    opacity = Math.random() * 0.5 + 0.1;
                    blur = 2;
                    twinkleSpeed = 0.2 + Math.random() * 0.8;
                } else {
                    // 75% dim stars
                    r = 200; g = 200; b = 255;
                    opacity = Math.random() * 0.2 + 0.1;
                    blur = 0;
                    // Dim stars twinkle slower
                    twinkleSpeed = 0.1 + Math.random() * 0.4;
                }
                
                // Add to stars array for animation
                stars.push({
                    x, y, size, r, g, b, 
                    opacity, 
                    baseOpacity: opacity, // Store original opacity for reference
                    blur,
                    twinkleSpeed,
                    twinkleOffset: Math.random() * Math.PI * 2 // Random phase offset
                });
            }
            
            // Draw initial stars
            drawStars();
            
            // Create a texture from the canvas
            const starsTexture = new THREE.CanvasTexture(starsCanvas);
            
            // Create the skybox material - inside facing
            const skyMaterial = new THREE.MeshBasicMaterial({
                map: starsTexture,
                side: THREE.BackSide, // Show on the inside of the sphere
                fog: false // Don't let fog affect the sky
            });
            
            // Create and add the sky mesh
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
            
            // Add a faint haze around the horizon to simulate atmosphere
            const hazeGeometry = new THREE.SphereGeometry(880, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.1);
            const hazeMaterial = new THREE.MeshBasicMaterial({
                color: 0x0A1525,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const haze = new THREE.Mesh(hazeGeometry, hazeMaterial);
            haze.position.y = -30; // Position slightly below to create horizon effect
            scene.add(haze);
            
            // Add animation function to the skybox for twinkling stars
            skybox.userData.animateStars = function(time) {
                let needsUpdate = false;
                
                // Only update every few frames for performance
                if (time % 5 === 0) {
                    // Update star brightness for twinkling effect
                    stars.forEach(star => {
                        // Calculate a sine wave for each star with its own frequency
                        const twinkle = Math.sin(time * 0.001 * star.twinkleSpeed + star.twinkleOffset);
                        // Adjust opacity based on twinkle value
                        star.opacity = star.baseOpacity * (0.7 + 0.3 * twinkle);
                        
                        // Occasionally make a star "flash" brightly
                        if (Math.random() < 0.0003) {
                            star.opacity = star.baseOpacity * 2;
                            needsUpdate = true;
                        }
                    });
                    
                    // Only redraw and update texture if needed
                    if (needsUpdate || time % 30 === 0) {
                        drawStars();
                        starsTexture.needsUpdate = true;
                    }
                }
            };
            
            return skybox;
        }

        // Function to add debug buttons for testing sounds
        function addDebugSoundButtons() {
            const buttonContainer = document.createElement('div');
            buttonContainer.style.position = 'absolute';
            buttonContainer.style.bottom = '10px';
            buttonContainer.style.left = '10px';
            buttonContainer.style.zIndex = '1000';
            buttonContainer.style.padding = '10px';
            buttonContainer.style.background = 'rgba(0, 0, 0, 0.7)';
            buttonContainer.style.borderRadius = '5px';
            
            const monsterSoundButton = document.createElement('button');
            monsterSoundButton.textContent = 'Test Monster Sound';
            monsterSoundButton.style.marginRight = '10px';
            monsterSoundButton.style.padding = '5px 10px';
            monsterSoundButton.addEventListener('click', () => {
                console.log("Testing monster sound via button...");
                playDetectionSound('monster');
            });
            
            const ghostSoundButton = document.createElement('button');
            ghostSoundButton.textContent = 'Test Ghost Sound';
            ghostSoundButton.style.padding = '5px 10px';
            ghostSoundButton.addEventListener('click', () => {
                console.log("Testing ghost sound via button...");
                playDetectionSound('ghost');
            });
            
            // Add file check buttons
            const checkMonsterFileButton = document.createElement('button');
            checkMonsterFileButton.textContent = 'Check Monster File';
            checkMonsterFileButton.style.marginRight = '10px';
            checkMonsterFileButton.style.marginTop = '5px';
            checkMonsterFileButton.style.padding = '5px 10px';
            checkMonsterFileButton.addEventListener('click', () => {
                fetch('Monster SFX.mp3')
                    .then(response => {
                        if (response.ok) {
                            console.log("Monster sound file exists and is accessible!");
                            alert("Monster sound file exists");
                        } else {
                            console.error("Monster sound file not found or inaccessible");
                            alert("Monster sound file NOT FOUND");
                        }
                    })
                    .catch(error => {
                        console.error("Error checking monster sound file:", error);
                        alert("Error checking monster sound file");
                    });
            });
            
            const checkGhostFileButton = document.createElement('button');
            checkGhostFileButton.textContent = 'Check Ghost File';
            checkGhostFileButton.style.padding = '5px 10px';
            checkGhostFileButton.style.marginTop = '5px';
            checkGhostFileButton.addEventListener('click', () => {
                fetch('qubodup-GhostMoan03.mp3')
                    .then(response => {
                        if (response.ok) {
                            console.log("Ghost sound file exists and is accessible!");
                            alert("Ghost sound file exists");
                        } else {
                            console.error("Ghost sound file not found or inaccessible");
                            alert("Ghost sound file NOT FOUND");
                        }
                    })
                    .catch(error => {
                        console.error("Error checking ghost sound file:", error);
                        alert("Error checking ghost sound file");
                    });
            });
            
            buttonContainer.appendChild(monsterSoundButton);
            buttonContainer.appendChild(ghostSoundButton);
            buttonContainer.appendChild(document.createElement('br'));
            buttonContainer.appendChild(checkMonsterFileButton);
            buttonContainer.appendChild(checkGhostFileButton);
            document.body.appendChild(buttonContainer);
        }

        function resetGame() {
            // Reset player health and position
            health = 100;
            playerVelocity.set(0, 0, 0);
            playerObject.position.set(0, 30, 0);
            camera.position.set(0, playerHeight, 0);
            camera.rotation.set(0, 0, 0);
            isHealthRegenerating = false;
            isCrouching = false;
            playerHeight = STANDING_HEIGHT;
            
            // Reset stamina
            stamina = 100;
            staminaRegenTimeout = 0;
            
            // Reset collected items
            collectibles.forEach(collectible => {
                collectible.visible = true;
                collectible.userData.collected = false;
            });
            collectedItems = 0;
            updateCollectibleCounter();
            
            // Reset enemies
            enemies.forEach(enemy => {
                // Reset basic enemy properties
                enemy.position.set(
                    (Math.random() - 0.5) * 100,
                    10,
                    (Math.random() - 0.5) * 100
                );
                enemy.userData.detectionRange = 20;
                enemy.userData.detectionCooldown = 0;
                enemy.userData.isPlayerDetected = false; // Reset detection status
                enemy.userData.lastDetectionTime = 0;
            });
            
            // Reset light-sensitive enemy (ghost)
            if (lightSensitiveEnemy) {
                lightSensitiveEnemy.position.set(
                    (Math.random() - 0.5) * 100,
                    20,
                    (Math.random() - 0.5) * 100
                );
                lightSensitiveEnemy.userData.isPlayerDetected = false; // Reset detection status
                lightSensitiveEnemy.userData.lastDetectionTime = 0;
                lightSensitiveEnemy.material.opacity = 0.3; // Reset to default transparency
            }
            
            // Reset game state
            gameRunning = true;
            updateHealthBar();
            updateStaminaBar();
        }

        init();
    </script>
</body>
</html>
